import flixel.FlxG;
import flixel.graphics.FlxGraphic;
import funkin.data.freeplay.player.PlayerRegistry;
import funkin.modding.PolymodErrorHandler;
import funkin.modding.base.Object;
import funkin.modding.module.Module;
import funkin.modding.module.ModuleHandler;
import funkin.play.character.CharacterDataParser;
import funkin.save.Save;
import funkin.util.MemoryUtil;
import funkin.util.SerializerUtil;
import funkin.util.assets.DataAssets;
import haxe.ds.StringMap;
import haxe.ds.Either;
import thx.Objects;

/**
 * A class responsible for handling character caches and data.
 */
class FS_CharacterDataHandler extends Object
{
  /**
   * The instance of this class.
   * There should only ever be one instance of this class.
   */
  static var instance:FS_CharacterDataHandler = null;

  /**
   * A map containing every character.
   */
  var characterMap:StringMap<String, Array<String, String>> = new StringMap();

  /**
   * Cache for JSON character data.
   */
  var jsonCharacterCache:StringMap<String, Array<Dynamic, Dynamic>, Array> = new StringMap();

  /**
   * A map of all the locked characters.
   */
  var lockedCharMap:StringMap<String> = new StringMap();

  public function new()
  {
    super();
  }

  /**
   * Initializes the character data handler.
   * This should be called once at the start of the game.
   */
  static function initialize():Void
  {
    if (FS_CharacterDataHandler.instance == null)
    {
      FS_CharacterDataHandler.instance = new FS_CharacterDataHandler();
      FS_CharacterDataHandler.instance.loadJSONDataCache();
      trace('[Funker Selector] Character Data Handler initialized.');
    }
    else
    {
      trace('[Funker Selector] Character Data Handler already initialized.');
      FS_CharacterDataHandler.instance.loadJSONDataCache();
    }
  }

  /**
   * Initializing and caching character data for use in the `CharacterMenu` SubState itself.
   *
   * Characters use a JSON file and are loaded from `data/funkerSelector/` and
   * then parsed, they can specify Game Over music, Blue Ball,
   * and Pause Menu music suffixes.
   * If no character type is specified in the JSON, it is pushed
   * to the Boyfriend character list.
   * If no character ID exists in the file (or the character ID is invalid), the character will be skipped.
   */
  function loadJSONDataCache():Void
  {
    var funkerJSONs:Array<String> = DataAssets.listDataFilesInPath('funkerSelector/');
    for (funker in funkerJSONs)
    {
      trace('[Funker Selector] Parsing JSON data for ' + funker);

      var data:FS_characterData = FS_CharacterDataHandler.parseJSONData(funker);

      // If the data is null (Caused by an issue when parsing the json file)
      if (data == null)
      {
        PolymodErrorHandler.showAlert("Funker Selector JSON Parsing Error",
          "Something went wrong when parsing the following JSON file:\n\n" + Assets.getPath(Paths.json('funkerSelector/' + funker)) +
          "\n\nPlease check the JSON file for any syntax errors.");
        continue;
      }

      // If the "characterID" field was not found.
      if (data.characterID == null)
      {
        PolymodErrorHandler.showAlert('Funker Selector JSON Parsing Error',
          'In "' + Assets.getPath(Paths.json('funkerSelector/' + funker)) +
          '":\n\nThe "characterID" field was not found. This character will be skipped to prevent any issues.');
        continue;
      }

      // If the Character ID is "default"
      if (data.characterID == 'default')
      {
        PolymodErrorHandler.showAlert('Funker Selector JSON Parsing Error',
          'In "'
          + Assets.getPath(Paths.json('funkerSelector/' + funker))
          + '":\n\nThe specified Character ID ('
          + data.characterID
          +
          ') is set to "default"! Please change it, since it will conflict with the "default" character object in the menu.\nThis character will be skipped to prevent any issues.');
        continue;
      }

      // If the specified Character ID does not exist in data/characters/
      if (!FS_CharacterDataHandler.charJSONCheck(data.characterID))
      {
        PolymodErrorHandler.showAlert('Funker Selector JSON Parsing Error',
          'In "'
          + Assets.getPath(Paths.json('funkerSelector/' + funker))
          + '":\n\nThe specified Character ID ('
          + data.characterID
          + ') is invalid. This character will be skipped to prevent any issues.');
        continue;
      }

      if (data.mustUnlock)
      {
        if (!isCharacterUnlocked(data.characterID, data.unlockMethod))
        {
          trace('[Funker Selector] Character ID ' + data.characterID + ' is locked!');
          lockedCharMap.set(data.characterID, data);
        }
        else if (!FS_SaveData.instance.isCharacterSeen(data.characterID))
        {
          trace('[Funker Selector] Character ID ' + data.characterID + ' was unlocked!');
          lockedCharMap.set(data.characterID, data);
        }
      }

      var variationList:Array = [];

      for (variation in data.characterVariations)
      {
        if (FS_CharacterDataHandler.charJSONCheck(variation.characterID))
        {
          variationList.push(variation.characterID);
        }
      }

      // NOTE: `jsonCharacterCache` and `characterMap` serve 2 different purposes.
      jsonCharacterCache.set(funker, [data, variationList.length]);
      characterMap.set(data.characterID, [funker, data.characterType]);

      trace("[Funker Selector] " + funker + " has " + variationList.length + " available variation(s).");
    }
  }

  /**
   * Parse a Funker Selector JSON file and return the data as `FS_characterData`.
   * @param characterID The character ID to use.
   * @return The character data as `FS_characterData`, or null if parsing fails.
   */
  static function parseJSONData(characterID:String = 'default'):FS_characterData
  {
    var filePath:String = Paths.json('funkerSelector/' + characterID);

    // Check if the file exists
    if (Assets.exists(filePath))
    {
      var parsedJSON:Dynamic = SerializerUtil.fromJSON(Assets.getText(filePath));

      if (parsedJSON == null)
      {
        trace('[Funker Selector] Failed to parse JSON file for character ID ' + characterID);
        return null;
      }

      // Merge the parsed data with the default character data, basically layering the parsed object on top of the default one.
      var result:FS_characterData = Objects.deepCombine(FS_CharacterDataHandler.getDefaultCharacterData(), parsedJSON);
      return result;
    }

    return null;
  }

  /**
   * Whether or not to show the unlock animation.
   * @param characterId The character ID to use.
   */
  function showUnlockAnimation(characterId:String):Bool
  {
    return isCharacterLocked(characterId) && isCharacterUnlocked(characterId) && !FS_SaveData.instance.isCharacterSeen(characterId);
  }

  /**
   * Whether or not the character is locked.
   * @param characterId The character ID to use.
   */
  function isCharacterLocked(characterId:String):Bool
  {
    return lockedCharMap.exists(characterId);
  }

  /**
   * Removes a locked character from the map.
   * @param characterId The character ID to use.
   */
  function unlockCharacter(characterId:String):Void
  {
    lockedCharMap.remove(characterId);
    FS_SaveData.instance.addCharacterSeen(characterId);
  }

  /**
   * Whether or not the character should be shown.
   * @param characterID The character ID we're using.
   * @return Bool
   *
   * Unlock Methods:
   * - playableCharacter: Checks if the associated playable character is unlocked.
   * - song: Checks if the song has been beaten on the specified difficulty list.
   * - storyWeek: Checks if the week has been beaten on the specified difficulty list.
   */
  function isCharacterUnlocked(characterID:String):Bool
  {
    trace("[Funker Selector] Checking unlock methods for ID " + characterID + " ...");
    var fs_characterData:FS_characterData = getCharacterData(characterID);
    var unlockMethod:Dynamic = fs_characterData.unlockMethod;

    switch (unlockMethod.type)
    {
      case 'playableCharacter':
        if (PlayerRegistry.instance.isCharacterOwned(characterID))
        {
          var ownerID:String = PlayerRegistry.instance.getCharacterOwnerId(characterID);
          var playableCharacter:PlayableCharacter = PlayerRegistry.instance.fetchEntry(ownerID);
          if (playableCharacter != null && playableCharacter.isUnlocked())
          {
            trace("[Funker Selector] Playable character is unlocked with ID " + ownerID);
            return true;
          }
          else
          {
            trace("[Funker Selector] Playable character is not unlocked with ID " + ownerID);
            return false;
          }
        }
      case "song":
        if (Save.instance.hasBeatenSong(unlockMethod.songID, unlockMethod.difficultyList, unlockMethod.songVariation))
        {
          if (unlockMethod.minimumRequiredRank != null)
          {
            if (unlockMethod?.difficultyList == null)
            {
              trace("[Funker Selector] Difficulty list was not specified for song ID " + unlockMethod.songID);
              return false;
            }
            for (difficulty in unlockMethod.difficultyList)
            {
              var savedRankValue:Int = FS_CharacterDataHandler.getRankValue(Save.instance.getSongRank(unlockMethod.songID, difficulty,
                unlockMethod.songVariation));
              var minimumRequiredRankValue:Int = FS_CharacterDataHandler.getRankValue(unlockMethod?.minimumRequiredRank);

              if (savedRankValue >= minimumRequiredRankValue)
              {
                trace("[Funker Selector] Song ID " + unlockMethod.songID + " was beaten with difficulty list " + unlockMethod.difficultyList
                  + " with the minimum required rank.");
                return true;
              }
              else
              {
                trace("[Funker Selector] Song ID " + unlockMethod.songID + " was beaten with difficulty list " + unlockMethod.difficultyList
                  + ", but it was not the minimum required rank.");
                return false;
              }
            }
          }
          else
          {
            trace("[Funker Selector] Song ID " + unlockMethod.songID + " was beaten with difficulty list " + unlockMethod.difficultyList);
            return true;
          }
        }
        else
        {
          trace("[Funker Selector] Song ID "
            + unlockMethod.songID
            + " has not been beaten with difficulty list "
            + unlockMethod.difficultyList);
          return false;
        }
      case 'storyWeek':
        if (Save.instance.hasBeatenLevel(unlockMethod.levelID, unlockMethod.difficultyList))
        {
          trace("[Funker Selector] Level ID " + unlockMethod.levelID + " was beaten with difficulty list " + unlockMethod.difficultyList);
          return true;
        }
        else
        {
          trace("[Funker Selector] Level ID "
            + unlockMethod.levelID
            + " has not been beaten with difficulty list "
            + unlockMethod.difficultyList);
          return false;
        }
      default:
        trace("[Funker Selector] Unlock Method " + unlockMethod.type + " not recognized.");
        return false;
    }
  }

  /**
   * Returns the base character data.
   */
  static function getDefaultCharacterData():FS_characterData
  {
    return {
      version: "1.0.0",
      characterID: "bf",
      characterType: "bf",
      mustUnlock: false,
      voiceID: null,
      introSwapFrame: 4,
      unlockMethod:
        {
          type: ""
        },
      description:
        {
          text: "No description was specified in the JSON file.",
          unlockCondition: "No unlock condition was specified in the JSON file."
        },
      characterMenu:
        {
          position: [200, 0],
          scale: 1.0,
          isPixel: false,
          flipX: false,
          selectedAnim: "hey",
          useCustomSprites: false,
          customSpriteData: null
        },
      suffixes:
        {
          gameOverMusic: null,
          blueBall: null,
          pauseMusic: null
        },
      characterVariations: []
    };
  }

  /**
   * Fetches the Character Data from the cache.
   * @param characterID The character ID we are using.
   * @param arrayNum The index specifying what part of the JSON cache to get.
   * @return The character data as a dynamic object.
   */
  function getCharacterData(characterID:String, ?arrayNum:Int = 0):FS_characterData
  {
    characterInfo = characterMap[characterID];

    if (characterInfo != null)
    {
      ownerJSONname = characterInfo[0];
      jsonData = jsonCharacterCache[ownerJSONname];

      // Checking to see if it's within bounds...
      if (jsonData == null || arrayNum < 0 || arrayNum >= jsonData.length) return null;

      characterData = jsonData[arrayNum];

      if (characterData == null) return null;
      return characterData;
    }
    else
    {
      return FS_CharacterDataHandler.getDefaultCharacterData();
    }
  }

  /**
   * Check if the JSON file in `data/characters/` ACTUALLY exists.
   *
   * I wrote this function because OpenFL Assets is case-insensitive
   * on Windows and macOS. This is for an edge case where the JSON filename
   * in data/characters/ has different capitalization than the Character ID
   * specified in the Funker Selector JSON. Because OpenFL is case insensitive, it will
   * always return true, which confuses Funker Selector!
   *
   * This was reported in issue [#1](https://github.com/AbnormalPoof/FunkerSelector/issues/1)!
   *
   * This should hopefully solve any and all issues like that one.
   *
   * @param string The character ID we're comparing.
   * @return Returns a true or false if the file exists.
   */
  static function charJSONCheck(string:String):Bool
  {
    if (Assets.exists(Paths.json('characters/' + string)))
    {
      var characterFiles = DataAssets.listDataFilesInPath('characters/');
      return characterFiles.contains(string);
    }
    return false;
  }

  /**
   * Returns a number based on rank.
   */
  static function getRankValue(rank:String):Int
  {
    switch (rank)
    {
      case "PERFECT_GOLD":
        return 5;
      case "PERFECT":
        return 4;
      case "EXCELLENT":
        return 3;
      case "GREAT":
        return 2;
      case "GOOD":
        return 1;
      case "SHIT":
        return 0;
      default:
        return -1;
    }
  }
}

/**
 * A typedef for Funker Selector's JSON character data.
 */
typedef FS_characterData =
{
  /**
   * The version of the JSON Format.
   */
  var version:String;

  /**
   * The character ID.
   */
  var characterID:String;

  /**
   * The character type.
   */
  var characterType:String;

  /**
   * Whether or not the character must be unlocked.
   */
  var mustUnlock:Bool;

  /**
   * The voice ID, optional. Defaults to the character ID.
   */
  var voiceID:String;

  /**
   * The frame where the turntable stops moving and the character appears in the Freeplay DJ's intro animation.
   * This is used for swapping out DJs.
   */
  var introSwapFrame:Int;

  /**
   * The unlock method. Can be one of the following:
   * - playableCharacter
   * - song
   * - storyWeek
   */
  var unlockMethod:Dynamic;

  /**
   * The character description.
   */
  var description:FS_descriptionData;

  /**
   * Data for the character sprites. Determines the appearance of the character in the menu.
   */
  var characterMenu:FS_characterMenuData;

  /**
   * Data for the character's suffixes.
   */
  var suffixes:FS_suffixesData;

  /**
   * Data for the character's variations.
   */
  var characterVariations:Array<FS_characterVariationData>;
}

/**
 * Data for character variations.
 */
typedef FS_characterVariationData =
{
  /**
   * The song ID to check for.
   */
  var songID:Either<String, Array<String>>;

  /**
   * The character ID to use.
   */
  var characterID:String;

  /**
   * The song variation to check for.
   */
  var songVariation:String;
}

/**
 * Data for suffixes.
 */
typedef FS_suffixesData =
{
  /**
   * The music suffix used in the Game Over screen.
   */
  var gameOverMusic:String;

  /**
   * The blue ball suffix used in the Game Over screen.
   */
  var blueBall:String;

  /**
   * The music suffix used in the Pause Menu.
   */
  var pauseMusic:String;
}

/**
 * Data for the character's appearance in the menu.
 */
typedef FS_characterMenuData =
{
  /**
   * The X and Y coordinates of the character.
   */
  var position:Array<Float, Float>;

  /**
   * The scale/size of the character.
   */
  var scale:Float;

  /**
   * Multiplies the scale by 6 and disables anti-aliasing.
   */
  var isPixel:Bool;

  /**
   * Whether or not to flip the character horizontally.
   */
  var flipX:Bool;

  /**
   * The animation to use when the character is selected.
   * The default animation is "hey"
   */
  var selectedAnim:String;
}

/**
 * Data for the character's descriptions.
 */
typedef FS_descriptionData =
{
  /**
   * The description text of the character.
   */
  var text:String;

  /**
   * The unlock condition, optional.
   */
  var unlockCondition:String;
}
