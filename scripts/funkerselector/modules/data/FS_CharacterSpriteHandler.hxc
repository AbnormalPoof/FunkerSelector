import flixel.FlxG;
import funkin.modding.base.Object;
import funkin.modding.module.ModuleHandler;
import funkin.play.character.BaseCharacter;
import funkin.play.character.CharacterDataParser;
import funkin.play.stage.Bopper;
import funkin.util.assets.FlxAnimationUtil;
import funkin.save.Save;
import haxe.ds.StringMap;
import thx.Iterators;

/**
 * Handles the creation and caching of the character sprites in the menu!
 */
class FS_CharacterSpriteHandler extends Object
{
  /**
   * The instance of the character sprite handler.
   * There should only be one instance of this class.
   */
  static var instance:FS_CharacterSpriteHandler = null;

  public function new()
  {
    super();
  }

  /**
   * Initializes the character sprite handler.
   */
  static function initialize():Void
  {
    if (FS_CharacterSpriteHandler.instance == null)
    {
      trace('[Funker Selector] Creating a new character sprite handler instance...');
      FS_CharacterSpriteHandler.instance = new FS_CharacterSpriteHandler();
    }
    else
    {
      trace('[Funker Selector] An instance of the character sprite handler already exists!');
    }
  }

  /**
   * Builds a character sprite with the given `FS_characterData`.
   * @param data The `FS_characterData` to use.
   * @return The built character sprite.
   */
  function buildCharacterSprite(data:FS_characterData):FunkinSprite
  {
    trace('[Funker Selector] Building character sprite for ' + data.characterID);

    var baseCharacter:BaseCharacter = CharacterDataParser.fetchCharacter(data.characterID);

    if (data.characterMenu.useCustomSprites && data.characterMenu.customSpriteData != null)
    {
      trace('[Funker Selector] Using custom sprite data for ' + data.characterID);
      var animationData:Array<Dynamic> = data.characterMenu.customSpriteData.animations;
      var characterSprite:Bopper = new Bopper(data.characterMenu.customSpriteData?.danceEvery ?? 1.0);
      var assetList:Array<String> = [];

      for (animation in data.characterMenu.customSpriteData?.animations)
      {
        if (animation.assetPath != null && !assetList.contains(animation.assetPath))
        {
          assetList.push(animation.assetPath);
        }

        characterSprite.setAnimationOffsets(animation.name, animation.offsets[0], animation.offsets[1]);
      }

      if (assetList.length <= 0)
      {
        characterSprite.loadSparrow(data.characterMenu.customSpriteData.assetPath);
      }
      else
      {
        trace("Creating multi-sparrow atlas for " + data.characterID + " with " + assetList.length + " assets.");

        var texture:FlxAtlasFrames = Paths.getSparrowAtlas(data.characterMenu.customSpriteData.assetPath);
        texture.parent.destroyOnNoUse = false;

        for (asset in assetList)
        {
          var subTexture:FlxAtlasFrames = Paths.getSparrowAtlas(asset);

          trace('Concatenating multi-sparrow atlas: ' + asset);
          subTexture.parent.destroyOnNoUse = false;

          texture.addAtlas(subTexture);
        }

        characterSprite.frames = texture;
      }

      FlxAnimationUtil.addAtlasAnimations(characterSprite, animationData);

      for (animation in data.characterMenu.customSpriteData?.animations)
      {
        characterSprite.setAnimationOffsets(animation.name, animation.offsets[0], animation.offsets[1]);
      }

      characterSprite.name = data.characterID;
      characterSprite.playAnimation(data.characterMenu.customSpriteData?.startingAnimation ?? 'idle');

      configureCharacterSprite(characterSprite, data);
      return characterSprite;
    }
    else if (baseCharacter != null)
    {
      configureCharacterSprite(baseCharacter, data);
      return baseCharacter;
    }
    else
    {
      return null;
    }
  }

  /**
   * Gets a character sprite with the given ID.
   * @param characterID The character ID to get.
   * @return The character sprite.
   */
  function getCharacterSprite(characterID:String):Null<FunkinSprite>
  {
    return buildCharacterSprite(FS_CharacterDataHandler.instance.getCharacterData(characterID));
  }

  /**
   * Configuring the JSON character, setting up position, scale, flipping, etc.
   * @param characterSprite The BaseCharacter to configure.
   * @param data The character data to use.
   * @return The configured BaseCharacter.
   */
  function configureCharacterSprite(characterSprite:FunkinSprite, data:Dynamic):FunkinSprite
  {
    if (data == null)
    {
      trace('[Funker Selector] ERROR: Data is null! Can\'t configure characterSprite.');
      return;
    }
    var funkin_characterData:CharacterData = CharacterDataParser.fetchCharacterData(data.characterID);
    var scaleFactor:Float = data.characterMenu.scale * (funkin_characterData?.isPixel ? 6 : 1);

    characterSprite.y += data.characterMenu.position[1];
    characterSprite.flipX = data.characterMenu.flipX;
    if (characterSprite is BaseCharacter)
    {
      characterSprite.setScale(scaleFactor);
    }
    else
    {
      characterSprite.scale.set(scaleFactor, scaleFactor);
    }
    characterSprite.antialiasing = !funkin_characterData?.isPixel ? true : false;
    characterSprite.pixelPerfectRender = funkin_characterData?.isPixel;

    return characterSprite;
  }

  override function toString():String
  {
    return '(FS_CharacterSpriteHandler)';
  }
}
