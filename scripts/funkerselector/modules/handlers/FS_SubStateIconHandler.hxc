import flixel.FlxG;
import flixel.text.FlxText;
import flixel.tweens.FlxEase;
import flixel.tweens.FlxTween;
import flixel.util.FlxTimer;
import funkin.audio.FunkinSound;
import funkin.data.song.SongRegistry;
import funkin.modding.base.ScriptedFunkinSprite;
import funkin.modding.base.ScriptedMusicBeatSubState;
import funkin.modding.module.Module;
import funkin.modding.module.ModuleHandler;
import funkin.play.character.CharacterDataParser;
import funkin.ui.AtlasText;
import funkin.ui.freeplay.FreeplayState;
import funkin.ui.story.StoryMenuState;
import haxe.ds.ObjectMap;

/**
 * Handles the character select icon for either Freeplay or Story Mode.
 */
class FS_SubStateIconHandler extends Module
{
  /**
   * The current Character Select SubState.
   * This is set to `null` when not in use.
   */
  var characterMenuState:MusicBeatSubState = null;

  /**
   * An `AtlasText` object, used for the Character Select button.
   */
  var characterMenuHotkey:AtlasText;

  /**
   * The Icon as a `FunkinSprite`.
   */
  var characterMenuIcon:FunkinSprite;

  /**
   * Original positions of the sprites for the transition.
   */
  var originalExitMovers:ObjectMap<Array<FunkinSprite>, MoveData> = new ObjectMap();

  /**
   * Should we open the Character Menu?
   */
  var shouldOpenMenu:Bool = true;

  /**
   * The position of the icon for Freeplay.
   */
  var ICON_DATA:Dynamic =
    {
      FREEPLAY:
        {
          scale: 0.65,
          position: [-20, 60]
        }
    };

  function new()
  {
    super('FS_SubStateIconHandler', 1500);
  }

  override function onScriptEvent(event:ScriptEvent):Void
  {
    super.onScriptEvent(event);
    // Update the Health Icon in the Character Menu button.
    if (event.type == "FS_EXITED_SUBSTATE")
    {
      characterMenuState = null;

      if (FlxG.state?.subState is FreeplayState)
      {
        shouldOpenMenu = false;
        FlxG.state.subState.busy = false;
        FlxG.state.subState.letterSort.inputEnabled = true;
        FlxG.state.subState.ostName.text = "OFFICIAL OST";

        if (characterMenuIcon != null)
        {
          var characterData:FS_CharacterData = CharacterDataParser.fetchCharacterData(ModuleHandler.getModule("FS_SaveDataHandler")
            ._asc.getSaveData()
            .characterIDs.bf);
          currentCharacterIcon = characterMenuIcon._asc.currentCharacterIcon;

          if (currentCharacterIcon.characterId != characterData?.healthIcon?.id)
          {
            currentCharacterIcon.configure(characterData?.healthIcon);
          }
        }

        var longestTimer:Float = 0;

        for (grpSpr in originalExitMovers.keys())
        {
          var moveData:Null<MoveData> = originalExitMovers.get(grpSpr);
          if (moveData == null) continue;

          for (spr in grpSpr)
          {
            if (spr == null) continue;

            var funnyMoveShit:MoveData = moveData;

            var moveDataX = funnyMoveShit.x ?? spr.x;
            var moveDataY = funnyMoveShit.y ?? spr.y;
            var moveDataSpeed = funnyMoveShit.speed ?? 0.2;
            var moveDataWait = funnyMoveShit.wait ?? 0.0;
            var capsule = funnyMoveShit.capsule ?? false;

            longestTimer = Math.max(longestTimer, moveDataSpeed + moveDataWait);

            if (capsule)
            {
              FlxTween.tween(spr.targetPos,
                {
                  y: moveDataY,
                  x: moveDataX
                }, moveDataSpeed, {ease: FlxEase.backOut});
            }
            else
            {
              FlxTween.tween(spr,
                {
                  y: moveDataY,
                  x: moveDataX
                }, moveDataSpeed, {ease: FlxEase.backOut});
            }
          }
        }

        new FlxTimer().start(longestTimer, (_) -> {
          shouldOpenMenu = true;
        });
      }
    }
  }

  override function onUpdate(event:UpdateScriptEvent):Void
  {
    super.onUpdate(event);
    if ((FlxG.state.subState is FreeplayState) || (FlxG.state is StoryMenuState))
    {
      // Open the CharacterMenu substate.
      // We need to make a new one everytime since it gets destroyed when it's closed.
      if (FlxG.keys.justPressed.G
        && (characterMenuHotkey?.visible ?? true)
        && !(FlxG.state?.subState?.busy ?? false)
        && shouldOpenMenu)
      {
        if (characterMenuState == null)
        {
          var freeplayBPM:Float = null;

          if (FlxG.state.subState is FreeplayState)
          {
            freeplayBPM = getFreeplayCapsuleBPM((FlxG.state.subState));
          }
          else
          {
            freeplayBPM = 120;
          }

          characterMenuState = ScriptedMusicBeatSubState.init('FS_CharacterMenu', [freeplayBPM]);

          FunkinSound.playOnce(Paths.sound('confirmMenu'));

          if (FlxG.state.subState is FreeplayState)
          {
            doTransition();
          }
          else
          {
            FlxG.state.persistentUpdate = false;
            trace("[Funker Selector] Opening the Character Select SubState...");
            FlxG.state.openSubState(characterMenuState);
          }
        }
        else
        {
          trace("[Funker Selector] The Character Select SubState is already open!");
        }
      }
    }
  }

  function doTransition():Void
  {
    var exitMovers:ObjectMap = new ObjectMap();

    originalExitMovers.clear();

    FlxG.state.subState.busy = true;
    FlxG.state.subState.letterSort.inputEnabled = false;

    exitMovers.set([FlxG.state.subState.dj],
      {
        x: -FlxG.state.subState.dj.x,
        y: 0,
        speed: 0.4,
        wait: 0
      });

    for (i in 0...FlxG.state.subState.grpCapsules.length)
    {
      var spr = FlxG.state.subState.grpCapsules.members[i];
      if (spr == null) continue;

      exitMovers.set([spr],
        {
          x: 0,
          y: FlxG.height - spr.y,
          speed: 0.4,
          capsule: true
        });
    }

    exitMovers.set([FlxG.state.subState.albumRoll, FlxG.state.subState.fp],
      {
        x: FlxG.width,
        y: 0,
        speed: 0.4,
        wait: 0
      });

    exitMovers.set([FlxG.state.subState.letterSort],
      {
        x: 0,
        y: -FlxG.state.subState.letterSort.y,
        speed: 0.65,
        wait: 0
      });

    // FIND THE FUCKING HIGHSCORE GRAPHIC
    for (spr in FlxG.state.subState.members)
    {
      if (spr == null) continue;

      if (spr.animation != null && spr.animation.getByName('highscore') != null)
      {
        exitMovers.set([spr],
          {
            x: spr.x,
            y: 0,
            speed: 0.55,
            wait: 0
          });
        break;
      }
    }

    // FIND THE FUCKING CLEAR BOX
    for (spr in FlxG.state.subState.members)
    {
      if (spr == null) continue;

      if (spr.x == 1165)
      {
        exitMovers.set([spr, FlxG.state.subState.txtCompletion],
          {
            x: 0,
            y: -spr.y,
            speed: 0.65,
            wait: 0
          });
        break;
      }
    }

    var diffSelLeft:DifficultySelector = null;
    var diffSelRight:DifficultySelector = null;

    // FIND THE FUCKING DIFFICULTY SELECTORS
    for (spr in FlxG.state.subState.members)
    {
      if (spr == null) continue;

      if (spr.x == 20 && spr.y == (FlxG.state.subState.grpDifficulties.y - 10))
      {
        diffSelLeft = spr;
        break;
      }
    }
    for (spr in FlxG.state.subState.members)
    {
      if (spr == null) continue;

      if (spr.x == 325 && spr.y == (FlxG.state.subState.grpDifficulties.y - 10))
      {
        diffSelRight = spr;
        break;
      }
    }

    exitMovers.set([diffSelLeft, diffSelRight, FlxG.state.subState.grpDifficulties],
      {
        x: -1000,
        y: 0,
        speed: 0.55,
        wait: 0
      });

    exitMovers.set([
      characterMenuIcon,
      characterMenuIcon._asc.currentCharacterIcon,
      characterMenuHotkey
    ],
      {
        x: -1000,
        y: 0,
        speed: 0.5,
        wait: 0
      });

    var longestTimer:Float = 0;

    for (grpSpr in exitMovers.keys())
    {
      var moveData:Null<MoveData> = exitMovers.get(grpSpr);
      if (moveData == null) continue;

      for (spr in grpSpr)
      {
        if (spr == null) continue;

        var funnyMoveShit:MoveData = moveData;

        var moveDataX = funnyMoveShit.x ?? spr.x;
        var moveDataY = funnyMoveShit.y ?? spr.y;
        var moveDataSpeed = funnyMoveShit.speed ?? 0.2;
        var moveDataWait = funnyMoveShit.wait ?? 0.0;
        var capsule = funnyMoveShit.capsule ?? false;

        originalExitMovers.set([spr],
          {
            x: spr.x,
            y: spr.y,
            speed: moveDataSpeed,
            wait: moveDataWait,
            capsule: capsule
          });

        longestTimer = Math.max(longestTimer, moveDataSpeed + moveDataWait);

        if (capsule)
        {
          FlxTween.tween(spr.targetPos,
            {
              y: moveDataY + spr.y,
              x: moveDataX + spr.x
            }, moveDataSpeed, {ease: FlxEase.backIn});
        }
        else
        {
          FlxTween.tween(spr,
            {
              y: moveDataY + spr.y,
              x: moveDataX + spr.x
            }, moveDataSpeed, {ease: FlxEase.backIn});
        }
      }
    }

    new FlxTimer().start(longestTimer - 0.3, (_) -> {
      FlxG.state.subState.persistentUpdate = true;
      FlxG.state.subState.persistentDraw = true;
      trace("[Funker Selector] Opening the Character Select SubState...");
      characterMenuState.camera = FlxG.state.subState.funnyCam;
      FlxG.state.subState.openSubState(characterMenuState);
    });
  }

  override function onSubStateOpenEnd(event:SubStateScriptEvent):Void
  {
    super.onSubStateOpenEnd(event);

    // Set up the Character Select button.
    if (event.targetState is FreeplayState)
    {
      if (characterMenuState != null)
      {
        trace("[Funker Selector] Character SubState still exists! Resetting...");
        characterMenuState = null;
      }

      shouldOpenMenu = true;

      characterMenuIcon = ScriptedFunkinSprite.init('FS_FreeplayIcon');
      characterMenuIcon.camera = event.targetState.funnyCam;
      characterMenuIcon.visible = false;

      characterMenuIcon.x = ICON_DATA.FREEPLAY.position[0];
      characterMenuIcon.y = ICON_DATA.FREEPLAY.position[1];
      characterMenuIcon.scale.set(ICON_DATA.FREEPLAY.scale, ICON_DATA.FREEPLAY.scale);

      characterMenuHotkey = new AtlasText(characterMenuIcon.x + 190, characterMenuIcon.y + 250, 'G', 'bold');
      characterMenuHotkey.visible = false;
      characterMenuHotkey.zIndex = 1001;
      characterMenuHotkey.camera = event.targetState.funnyCam;

      event.targetState.add(characterMenuIcon);
      event.targetState.add(characterMenuHotkey);

      event.targetState.dj.onIntroDone.add(function() {
        characterMenuIcon.visible = true;
        characterMenuIcon.animation.play('intro');
        characterMenuIcon.animation.onFinish.add(function(_) {
          characterMenuIcon.animation.play('idle');
          characterMenuHotkey.visible = true;
        });
      });
    }
  }

  override function onStateChangeEnd(event:StateChangeScriptEvent):Void
  {
    super.onStateChangeEnd(event);
    if (event.targetState is StoryMenuState)
    {
      if (characterMenuState != null)
      {
        trace("[Funker Selector] Character SubState still exists! Resetting...");
        characterMenuState = null;
      }

      // Character Menu icon doesn't show properly in Story Mode, so we just use text instead!
      var characterMenuText:FlxText = configureText(null, "Press G to open\nthe Funker Selector\nMenu!", [890, 575], 35, Paths.font("PhantomMuff.ttf"));

      event.targetState.add(characterMenuText);
    }
  }

  /**
   * Gets the BPM of the currently selected song in Freeplay.
   * @param freeplay The Freeplay SubState to use as a dynamic object.
   * @return The BPM.
   */
  function getFreeplayCapsuleBPM(freeplay:Dynamic):Float
  {
    var daSongCapsule:SongMenuItem = freeplay.grpCapsules.members[freeplay.curSelected];
    var songBPM:Float = daSongCapsule?.freeplayData?.songStartingBpm;

    if (daSongCapsule.songText.text == 'Random' && songBPM == null)
    {
      var songMusicData:Null<SongMusicData> = SongRegistry.instance.parseMusicData('freeplayRandom');
      songBPM = songMusicData.timeChanges[0].bpm;
    }

    if (songBPM == null) songBPM = 120;

    return songBPM;
  }

  /**
   * Helper function for configuring a FlxText
   * @param object The FlxText object
   * @param text The text itself
   * @param offsets The offsets as an array
   * @param size The size of the text
   * @param font The font
   * @return A FlxText object
   */
  function configureText(object:FlxText, ?text:String = "", ?offsets:Array<Int>, ?size:Int = 38, ?font:String = null):FlxText
  {
    if (text == null) text = "";
    if (offsets == null) offsets = [0, 0];
    if (size == null) size = 35;
    if (object == null)
    {
      object = new FlxText(0, 0, 0, "PLACEHOLDER");
    }

    object.text = text;
    object.x += offsets[0];
    object.y += offsets[1];
    if (font != null) object.setFormat(font, size, null, 'center');

    return object;
  }
}
