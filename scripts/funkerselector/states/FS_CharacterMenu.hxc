import Array;
import Std;
import haxe.Json;
import haxe.ds.ObjectMap;
import haxe.ds.StringMap;
import haxe.ds.IntMap;
import lime.app.Application;
import flixel.FlxG;
import flixel.addons.text.FlxTypeText;
import flixel.group.FlxTypedSpriteGroup;
import flixel.math.FlxMath;
import flixel.text.FlxText;
import flixel.text.FlxTextBorderStyle;
import flixel.tweens.FlxEase;
import flixel.tweens.FlxTween;
import flixel.util.FlxTimer;
import flixel.util.FlxSpriteUtil;
import funkin.util.FlxColorUtil;
import funkin.audio.FunkinSound;
import funkin.data.animation.AnimationDataUtil;
import funkin.data.freeplay.player.PlayerRegistry;
import funkin.data.song.SongRegistry;
import funkin.graphics.FunkinCamera;
import funkin.graphics.FunkinSprite;
import funkin.graphics.shaders.AngleMask;
import funkin.modding.PolymodErrorHandler;
import funkin.modding.base.ScriptedFunkinSprite;
import funkin.modding.events.ScriptEvent;
import funkin.modding.module.ModuleHandler;
import funkin.play.GameOverSubState;
import funkin.play.PauseSubState;
import funkin.play.character.BaseCharacter;
import funkin.play.character.CharacterDataParser;
import funkin.play.components.HealthIcon;
import funkin.play.stage.Bopper;
import funkin.save.Save;
import funkin.ui.MusicBeatSubState;
import funkin.ui.charSelect.Lock;
import funkin.ui.freeplay.FreeplayState;
import funkin.ui.freeplay.DifficultySelector;
import funkin.ui.freeplay.charselect.PlayableCharacter;
import funkin.ui.story.StoryMenuState;
import funkin.util.Constants;
import funkin.util.MathUtil;
import funkin.util.ReflectUtil;
import funkin.util.SortUtil;
import funkin.util.WindowUtil;
import funkin.util.assets.DataAssets;
import funkin.util.tools.IteratorTools;
import openfl.display.BitmapData;
import openfl.geom.Matrix;

/**
 * This is a substate that acts as a Character Selection screen.
 */
class FS_CharacterMenu extends MusicBeatSubState
{
  /**
   * The character name, displayed at the top of the screen.
   */
  var characterName:FlxText;

  /**
   * A list of character variations. Used in the pop-up when selecting the `DEBUG_MENU` keybind.
   */
  var variationText:FlxText;

  /**
   * An indicator that the current character is selected.
   */
  var selected:FlxText;

  /**
   * A counter that shows the current character's index, and the total amount of characters.
   * Displayed as "< current / total >".
   */
  var characterCount:FlxText;

  /**
   * The character's description. This is a `FlxTypeText` for the typewriter effect.
   * This is automatically resized to fit inside `blackBack`.
   */
  var characterDescription:FlxTypeText;

  /**
   * The character's description text, grabbed from the character's JSON.
   */
  var descriptionText:String;

  /**
   * A box where all the hotkeys are displayed.
   */
  var hotkeyBox:FunkinSprite;

  /**
   * The graphic that overlays the backing card.
   */
  var blackBack:FunkinSprite;

  /**
   * The left difficulty arrow.
   */
  var leftDifficultyArrow:FunkinSprite;

  /**
   * The right difficulty arrow.
   */
  var rightDifficultyArrow:FunkinSprite;

  /**
   * Stolen from `FreeplayState` LMAO
   */
  var newGraphic:FunkinSprite;

  /**
   * Again, stolen from `FreeplayState` LOL
   */
  var overlayShit:FunkinSprite;

  /**
   * A lock for Simplify UI.
   */
  var lockedChill:Lock;

  /**
   * The unlock sound that plays during the unlock animation.
   */
  var unlockSound:FunkinSound;

  /**
   * The camera for certain UI elements.
   */
  var uiCamera:FunkinCamera;

  /**
   * The camera for sprites.
   */
  var spriteCamera:FunkinCamera;

  /**
   * A filtered character array for the current page.
   * We still use this array since `FS_CharacterMenu` is built around Arrays.
   */
  var filteredKeys:Array<String> = [];

  /**
   * The 1st icon grid that scrolls to the left at the top.
   */
  var iconGridTop:FlxTypedSpriteGroup<HealthIcon> = null;

  /**
   * The 2nd icon grid that scrolls to the right at the bottom.
   */
  var iconGridBottom:FlxTypedSpriteGroup<HealthIcon> = null;

  /**
   * For the top text in the menu.
   * These alternate depending on the page.
   */
  var topText:Array<String> = ["PLAYABLE CHARACTERS", "OPPONENT CHARACTERS", "SPEAKER CHARACTERS"];

  /**
   * The color of the top text.
   * These alternate depending on the page.
   */
  var topTextColor:Array<FlxColor> = [0xFF2DB2D2, 0xFFAF66CE, 0xFFA7004C];

  /**
   * Character slots in the order of "PLAYABLE CHARACTERS", "OPPONENT CHARACTERS", and "SPEAKER CHARACTERS".
   * These are an array of arrays, they can have multiple aliases for better flexibility.
   *
   * `pageIndex` uses this to determine which page is currently selected.
   */
  var characterSlots:Array<String> = [['bf', 'player'], ['dad', 'opponent'], ['gf', 'speaker']];

  /**
   * Stuff related to the icon grid.
   */
  var currentCharacterIcon:HealthIcon;

  /**
   * The index of the currently selected character.
   */
  var currentCharacterIndex:Int = 0;

  /**
   * The index of the current page.
   */
  var currentPageIndex:Int = 0;

  /**
   * This is a `FlxTypedSpriteGroup` for the character wheel.
   * This is a bit janky but it works so whatever.
   */
  var characterWheel:FlxTypedSpriteGroup<BaseCharacter> = new FlxTypedSpriteGroup();

  /**
   * The current song BPM in Freeplay.
   */
  var songBPM:Float = null;

  /**
   * The current character ID.
   */
  var currentCharacterID:String = 'default';

  /**
   * If enabled, the menu will stop responding to inputs.
   * This is used for the unlock animation
   */
  var busy:Bool = true;

  /**
   * Script Event called when this SubState is opened.
   */
  var FS_OPENED_SUBSTATE:String = "FS_OPENED_SUBSTATE";

  /**
   * Script Event called when this SubState is closed.
   */
  var FS_EXITED_SUBSTATE:String = "FS_EXITED_SUBSTATE";

  /**
   * The base scroll speed for the icon grid.
   */
  var ICON_SCROLL_SPEED:Float = 0.3;

  /**
   * Stolen from `FreeplayState`.
   */
  var spamTimer:Float = 0;

  /**
   * Stolen from `FreeplayState`.
   */
  var spamming:Bool = false;

  /**
   * Stolen from `FreeplayState`.
   */
  var angleMaskShader:AngleMask = new AngleMask();

  /**
   * MODULES
   * These are modules that are called throughout the menu.
   */
  /**
   * The `FS_CharacterDataHandler` module.
   */
  var FS_CharacterDataHandler:Module = ModuleHandler.getModule("FS_CharacterDataHandler")._asc;

  /**
   * The `FS_SaveDataHandler` module.
   */
  var FS_SaveDataHandler:Module = ModuleHandler.getModule("FS_SaveDataHandler")._asc;

  /**
   * The `FS_CharacterSpriteHandler` module.
   */
  var FS_CharacterSpriteHandler:Module = ModuleHandler.getModule("FS_CharacterSpriteHandler")._asc;

  public function new(songBPM:Float)
  {
    super();

    this.songBPM = songBPM;
  }

  public override function create():Void
  {
    super.create();

    setupUIStuff();
    updateFilteredKeys();

    ModuleHandler.callEvent(new ScriptEvent(FS_OPENED_SUBSTATE));
  }

  public override function update(elapsed:Float):Void
  {
    super.update(elapsed);

    conductorInUse.update();

    adjustFontSize(characterDescription ?? null);

    for (icon in iconGridTop)
    {
      var speedFactor:Float = (Math.min(conductorInUse.bpm, 300) / 60) * (FlxG.elapsed / (1 / FlxG.drawFramerate));

      icon.x -= ICON_SCROLL_SPEED * speedFactor;

      if (icon.x < -icon.width)
      {
        icon.x += (FlxG.width + icon.width) + 70;
      }
    }

    for (icon in iconGridBottom)
    {
      var speedFactor:Float = (Math.min(conductorInUse.bpm, 300) / 60) * (FlxG.elapsed / (1 / FlxG.drawFramerate));

      icon.x += ICON_SCROLL_SPEED * speedFactor;

      if (icon.x > FlxG.width)
      {
        icon.x -= (FlxG.width + icon.width) + 70;
      }
    }

    // Adding some useful stuff to the variable watch window.
    if (Constants.DEBUG_BUILD)
    {
      FlxG.watch.addQuick("currentPageIndex", currentPageIndex);
      FlxG.watch.addQuick("currentCharacterIndex", currentCharacterIndex);
      FlxG.watch.addQuick("currentCharacterID", currentCharacterID);
      FlxG.watch.addQuick("filteredKeys", filteredKeys);
      FlxG.watch.addQuick("bf", FS_SaveDataHandler.getSaveData().characterIDs.bf);
      FlxG.watch.addQuick("gf", FS_SaveDataHandler.getSaveData().characterIDs.gf);
      FlxG.watch.addQuick("dad", FS_SaveDataHandler.getSaveData().characterIDs.dad);
    }

    if (!busy) handleKeyShit();

    if (!FS_SaveDataHandler.getSaveData().preferences.potatoMode)
    {
      for (index in 0...characterWheel.members.length)
      {
        var item:Dynamic = characterWheel.members[index];
        var characterID:String = item.characterId ?? (item.name ?? null);
        var fs_characterData:FS_characterData = FS_CharacterDataHandler.getCharacterData(characterID);

        var xOffset:Float = fs_characterData.characterMenu.position[0];
        var relativeIndex:Int = index - currentCharacterIndex;

        if (relativeIndex > Math.floor(characterWheel.members.length / 2))
        {
          relativeIndex -= characterWheel.members.length;
        }
        else if (relativeIndex < -Math.floor(characterWheel.members.length / 2))
        {
          relativeIndex += characterWheel.members.length;
        }

        var baseX:Float = relativeIndex * 800;
        var targetX:Float = baseX + xOffset + 500;

        if (!(Math.abs(relativeIndex) <= Math.floor(characterWheel.members.length / 3)))
        {
          item.kill();
        }
        else
        {
          item.revive();
        }

        if (item.alive && item.x != targetX)
        {
          item.x = MathUtil.smoothLerp(item.x, targetX, elapsed, 0.20);
        }
      }
    }
  }

  function buildCharacterWheel():Void
  {
    characterWheel.clear();

    for (i in 0...filteredKeys.length)
    {
      loadCharacter(filteredKeys[i]);
    }

    uiCamera.visible = true;
    refresh();
    changeCharacter();
  }

  function loadCharacter(characterID:String):Void
  {
    var fs_characterData = FS_CharacterDataHandler.getCharacterData(characterID);

    if (FS_CharacterDataHandler.lockedCharMap.exists(characterID) || characterID == 'default')
    {
      var lockedChill = FunkinSprite.createSparrow(200, 250, 'funkerSelector/locked_character');
      lockedChill.animation.addByPrefix('idle', 'LOCKED MAN0', 24, false);
      lockedChill.animation.addByPrefix('denied', 'cannot select0', 24, false);
      lockedChill.animation.addByPrefix('death', 'locked man explodes0', 24, false);
      lockedChill.animation.play('idle');
      lockedChill.animation.finishCallback = function(_) {
        lockedChill.offset.set();
        lockedChill.animation.play('idle');
      };
      lockedChill.scale.set(1.2, 1.2);
      lockedChill.camera = spriteCamera;

      if (characterID == 'default')
      {
        lockedChill.visible = false;
      }

      characterWheel.add(lockedChill);
    }
    else
    {
      trace("[Funker Selector] Configuring sprite...");

      var characterSprite:FunkinSprite = FS_CharacterSpriteHandler.getCharacterSprite(characterID);

      if (characterSprite != null)
      {
        characterSprite.camera = spriteCamera;
        characterWheel.add(characterSprite);
      }
    }
  }

  /**
   * Stolen from `StoryMenuState.hx` LOL
   *
   * Changes the selected character.
   * @param change +1 (right), -1 (left)
   */
  function changeCharacter(change:Int = 0):Void
  {
    var prevIndex:Int = currentCharacterIndex;
    currentCharacterIndex = (prevIndex + (change + filteredKeys.length)) % filteredKeys.length;

    currentCharacterID = filteredKeys[currentCharacterIndex];

    if (currentCharacterIndex != prevIndex)
    {
      if (FS_SaveDataHandler.getSaveData().preferences.preferredSFX == "charSelect")
      {
        FunkinSound.playOnce(Paths.sound('CS_select'), 0.2);
      }
      else
      {
        FunkinSound.playOnce(Paths.sound('scrollMenu'), 0.4);
      }
    }

    updateCharInfo();

    characterCount.text = "< " + (currentCharacterIndex + 1) + " / " + filteredKeys.length + " >";
    characterCount.screenCenter(0x01);
    characterCount.x += 220;
  }

  /**
   * Changes the current page.
   * @param change +1 (right), -1 (left)
   */
  function changePage(change:Int = 0):Void
  {
    var prevIndex:Int = currentPageIndex;
    currentPageIndex = (prevIndex + (change + characterSlots.length)) % characterSlots.length;

    // Reset currentCharacterIndex
    currentCharacterIndex = 0;

    updateFilteredKeys();
    if (!FS_SaveDataHandler.getSaveData().preferences.potatoMode)
    {
      buildCharacterWheel();
    }
    changeCharacter();
  }

  function beatHit():Void
  {
    bopDaThing();
    if (!FS_SaveDataHandler.getSaveData().preferences.potatoMode)
    {
      for (index in 0...characterWheel.members.length)
      {
        var item:Dynamic = characterWheel.members[index];
        if (item is Bopper)
        {
          item.dance();
        }
      }
    }

    if (conductorInUse.currentBeat % 4 == 0)
    {
      if (uiCamera != null)
      {
        FlxTween.tween(uiCamera, {zoom: 1.02}, 0.01, {ease: FlxEase.quartOut});
      }
    }
  }

  /**
   * Updates the `filteredKeys` array based on the current `currentPageIndex`.
   */
  function updateFilteredKeys():Void
  {
    trace('[Funker Selector] Sorting the Character Map...');

    filteredKeys = IteratorTools.array(FS_CharacterDataHandler.characterMap.keys()).filter(function(shit) {
      characterType = FS_CharacterDataHandler.characterMap[shit][1];
      var types:Array<String> = (characterType is Array) ? characterType : [characterType];

      for (pageType in characterSlots[currentPageIndex])
      {
        if (types.contains(pageType))
        {
          return true;
        }
      }
      return false;
    });

    filteredKeys.sort(function(a:String, b:String):Int {
      characterDataA = CharacterDataParser.fetchCharacterData(a);
      characterDataB = CharacterDataParser.fetchCharacterData(b);

      return SortUtil.alphabetically(characterDataA?.name, characterDataB?.name);
    });

    filteredKeys.insert(0, 'default');

    trace("[Funker Selector] Updated the character list:\n" + filteredKeys);
  }

  /**
   * Make a super awesome cool icon grid!
   * @param spacing The spacing of the icons.
   * @param alpha The alpha of the icons.
   * @param rows Optional number of rows.
   * @param columns Optional number of columns.
   *
   * This is disabled if "Simplify UI" is turned on in the Options Menu.
   */
  function createIconGrid(spacing:Int, ?alpha:Float = 0.2, ?rows:Int = -1, ?columns:Int = -1):FlxTypedSpriteGroup<HealthIcon>
  {
    var characterData = CharacterDataParser.fetchCharacterData(currentCharacterID);

    // Calculate columns and rows if not provided
    if (columns <= 0) columns = Math.ceil(FlxG.width / (spacing * 2));
    if (rows <= 0) rows = Math.ceil(FlxG.height / (spacing * 2));

    var xStart = (FlxG.width - columns * spacing * 2) / 2;
    var yStart = (FlxG.height - rows * spacing * 2) / 2;
    var iconGrid:FlxTypedSpriteGroup<HealthIcon> = new FlxTypedSpriteGroup();

    for (i in 0...rows)
    {
      for (j in 0...columns)
      {
        var icon = new HealthIcon('dad', 0);
        icon.x = xStart + (j * 2) * spacing;
        icon.y = yStart + (i * 2) * spacing;
        icon.alpha = alpha;

        icon.configure(characterData?.healthIcon ?? 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');

        iconGrid.add(icon);
      }
    }

    return iconGrid;
  }

  /**
   * Sets up the UI.
   */
  function setupUIStuff():Void
  {
    spriteCamera = new FunkinCamera('UISprites');
    FlxG.cameras.add(spriteCamera, false);
    spriteCamera.bgColor = 0x0;

    uiCamera = new FunkinCamera('UIElements');
    FlxG.cameras.add(uiCamera, false);
    uiCamera.bgColor = 0x0;
    uiCamera.visible = false;

    if (_parentState is FreeplayState)
    {
      _parentState.ostName.text = 'LOADING CHARACTERS';
    }

    blackBack = FunkinSprite.create(-500, -20, 'freeplay/pinkBack');
    blackBack.color = 0xFF000000;
    blackBack.alpha = 0;
    blackBack.zIndex = 200;
    blackBack.camera = spriteCamera;
    add(blackBack);

    overlayShit = new FunkinSprite(FlxG.width, 65).makeGraphic(1000, 700, 0xB3FFD4E9);
    overlayShit.shader = angleMaskShader;
    overlayShit.camera = spriteCamera;
    overlayShit.zIndex = 150;

    if (_parentState is StoryMenuState)
    {
      overlayShit.y -= 10;
    }

    add(overlayShit);

    selectText = configureText(null, null, [170, 15], 50, 'VCR OSD Mono');
    selectText.screenCenter(0x01);
    selectText.zIndex = 300;
    selectText.camera = uiCamera;
    selectText.visible = !(_parentState is StoryMenuState);
    add(selectText);

    characterCount = configureText(null, null, [170, 80], 45, Paths.font("PhantomMuff.ttf"));
    characterCount.color = 0xFFE3E1E1;
    characterCount.zIndex = 300;
    characterCount.camera = uiCamera;
    add(characterCount);

    characterDescription = configureText(null, "PLACEHOLDER", [30, 300], 25, Paths.font("PhantomMuff.ttf"), 'left', true);
    characterDescription.wordWrap = true;
    characterDescription.fieldWidth = 430;
    characterDescription.zIndex = 400;
    characterDescription.camera = uiCamera;
    add(characterDescription);

    selected = configureText(null, '(SELECTED)', [110, 250], 40, Paths.font("PhantomMuff.ttf"));
    selected.color = 0xFF53FF38;
    selected.visible = false;
    selected.zIndex = 400;
    selected.camera = uiCamera;
    add(selected);

    // TODO: Remove this, replace it with a neater UI for hotkeys
    hotkeyBox = new FunkinSprite(0, 0);
    hotkeyBox.makeSolidColor(600, 600, 0xFF000000);
    hotkeyBox.camera = uiCamera;
    hotkeyBox.alpha = 0.8;
    hotkeyBox.zIndex = 500;
    hotkeyBox.screenCenter();
    hotkeyBox.visible = false;
    add(hotkeyBox);

    hotkeyHintText = configureText(null, controls.getDialogueNameFromToken("RESET", true) + ' - Hotkeys', [40, 660], 30, 'VCR OSD Mono');
    hotkeyHintText.color = 0xFFE3E1E1;
    hotkeyHintText.camera = uiCamera;
    hotkeyHintText.zIndex = 300;
    add(hotkeyHintText);

    hotkeyBoxText = configureText(null,
      controls.getDialogueNameFromToken("FREEPLAY_FAVORITE", true)
      + ' - Reset everything to default.\n\n'
      + controls.getDialogueNameFromToken("FREEPLAY_CHAR_SELECT", true)
      + ' - Jump to the currently selected character.\n\n'
      + controls.getDialogueNameFromToken("FREEPLAY_LEFT", true)
      + ' - Switch to the previous page.\n\n'
      + controls.getDialogueNameFromToken("FREEPLAY_RIGHT", true)
      + ' - Switch to the next page.\n\n'
      + controls.getDialogueNameFromToken("BACK", true)
      + ' - Close this.\n\n'
      + controls.getDialogueNameFromToken("DEBUG_MENU", true)
      + ' - Show available character variations.',
      [350, 100], 35, Paths.font("PhantomMuff.ttf"));
    hotkeyBoxText.camera = uiCamera;
    hotkeyBoxText.wordWrap = true;
    hotkeyBoxText.visible = false;
    hotkeyBoxText.fieldWidth = 600;
    hotkeyBoxText.zIndex = 600;
    add(hotkeyBoxText);

    characterName = configureText(null, null, [170, 130], 50, Paths.font("PhantomMuff.ttf"));
    characterName.camera = uiCamera;
    characterName.zIndex = 300;
    add(characterName);

    variationText = configureText(null, null, [170, 180], 30, Paths.font("PhantomMuff.ttf"));
    variationText.color = 0xFFFF8F2E;
    variationText.camera = uiCamera;
    variationText.zIndex = 300;
    add(variationText);

    leftDifficultyArrow = ScriptedFunkinSprite.init('FS_DifficultySelectorLeft');
    leftDifficultyArrow.setPosition(500, 300);
    leftDifficultyArrow.scale.set(1.5, 1.5);
    leftDifficultyArrow.camera = uiCamera;
    leftDifficultyArrow.zIndex = 500;
    add(leftDifficultyArrow);

    rightDifficultyArrow = ScriptedFunkinSprite.init('FS_DifficultySelectorRight');
    rightDifficultyArrow.setPosition(1150, leftDifficultyArrow.y);
    rightDifficultyArrow.scale.set(1.5, 1.5);
    rightDifficultyArrow.camera = uiCamera;
    rightDifficultyArrow.zIndex = 500;
    add(rightDifficultyArrow);

    if (!FS_SaveDataHandler.getSaveData().preferences.potatoMode)
    {
      characterWheel.zIndex = 170;
      characterWheel.camera = spriteCamera;
      add(characterWheel);
    }

    if (FS_SaveDataHandler.getSaveData().preferences.potatoMode)
    {
      lockedChill = new Lock(530, 270, FlxG.random.int(1, 9));
      lockedChill.onAnimationComplete.add(function(name) {
        if (name != 'selected') lockedChill.playAnimation('selected');
      });
      lockedChill.playAnimation('selected');
      lockedChill.scale.set(2, 2);
      lockedChill.camera = uiCamera;
      lockedChill.zIndex = 300;
      lockedChill.visible = false;
      lockedChill.updateHitbox();
      add(lockedChill);
    }

    newGraphic = FunkinSprite.createSparrow(200, 255, 'freeplay/freeplayCapsule/new');
    newGraphic.animation.addByPrefix('new', 'NEW notif', 24);
    newGraphic.animation.play('new');
    newGraphic.camera = uiCamera;
    newGraphic.scale.set(1.6, 1.6);
    newGraphic.visible = false;
    newGraphic.zIndex = 300;
    add(newGraphic);

    currentCharacterIcon = new HealthIcon('dad', 0);
    currentCharacterIcon.camera = uiCamera;
    currentCharacterIcon.zIndex = 300;
    add(currentCharacterIcon);

    iconGridTop = createIconGrid(150, 0.2, 1, 10);
    iconGridTop.zIndex = 160;
    iconGridTop.y -= 150;
    iconGridTop.camera = spriteCamera;
    iconGridTop.visible = false;
    add(iconGridTop);

    iconGridBottom = createIconGrid(150, 0.2, 1, 10);
    iconGridBottom.zIndex = 160;
    iconGridBottom.y += 360;
    iconGridBottom.camera = spriteCamera;
    iconGridBottom.visible = false;
    add(iconGridBottom);

    unlockSound = new FunkinSound();
    unlockSound.loadEmbedded(Paths.sound('funkerSelector/charUnlock'));
    unlockSound.volume = 1;

    // Apply the zIndex
    refresh();

    // Set the window title.
    WindowUtil.setWindowTitle('Friday Night Funkin\' - Funker Selector Menu');

    trace('[Funker Selector] UI has been set up.');
    conductorInUse.forceBPM(songBPM);

    FlxTween.tween(blackBack, {x: -6}, 0.7, {ease: FlxEase.quintOut});
    FlxTween.tween(overlayShit, {x: 400}, 0.7, {ease: FlxEase.quintOut});
    FlxTween.tween(blackBack, {alpha: 1}, 1,
      {
        ease: FlxEase.quartOut,
        onComplete: function(twn:FlxTween) {
          // TODO: Have a transition to the ui or something IDK
          _parentState.persistentUpdate = false;
          _parentState.persistentDraw = true;

          if (!FS_SaveDataHandler.getSaveData().preferences.potatoMode)
          {
            buildCharacterWheel();
          }
          else
          {
            uiCamera.visible = true;
          }

          jumpToCurSelected(true);

          iconGridTop.visible = true;
          iconGridBottom.visible = true;

          busy = false;

          if (_parentState is FreeplayState)
          {
            _parentState.ostName.text = 'FUNKER SELECTOR';
          }
        }
      });
  }

  /**
   * Bopping the icons, because why not?
   */
  function bopDaThing():Void
  {
    if (currentCharacterIcon != null)
    {
      if (currentCharacterIcon.width > currentCharacterIcon.height)
      {
        currentCharacterIcon.setGraphicSize(Std.int(currentCharacterIcon.width + (150 * currentCharacterIcon.size.x * 0.2)), 0);
      }
      else
      {
        currentCharacterIcon.setGraphicSize(0, Std.int(currentCharacterIcon.height + (150 * currentCharacterIcon.size.y * 0.2)));
      }

      currentCharacterIcon.angle += 1;

      currentCharacterIcon.updateHitbox();
      currentCharacterIcon.updatePosition();
    }
  }

  /**
   * Flash the screen with a specific color.
   * @param color The color to use.
   * @param duration The duration of the flash.
   * @param alpha The alpha of the flash.
   */
  function flashScreen(color:FlxColor, duration:Float, ?alpha:Float = 1)
  {
    var duration:Float = duration;
    var alpha:Float = alpha;

    var white = new FunkinSprite(0, 0);
    white.makeSolidColor(FlxG.width, FlxG.height, color);
    white.alpha = 0;
    white.camera = uiCamera;
    this.add(white);

    FlxTween.tween(white, {alpha: alpha}, duration,
      {
        ease: FlxEase.quadOut,
        onComplete: function(twn:FlxTween) {
          FlxTween.tween(white, {alpha: alpha}, duration,
            {
              ease: FlxEase.quadOut,
              onComplete: function(twn:FlxTween) {
                this.remove(white);
              }
            });
        }
      });
  }

  /**
   * Reponsible for handling inputs in the menu.
   */
  function handleKeyShit():Void
  {
    if (controls.BACK)
    {
      if (hotkeyBox.visible)
      {
        hotkeyBox.visible = false;
        hotkeyBoxText.visible = false;
      }
      else
      {
        FunkinSound.playOnce(Paths.sound('cancelMenu'));

        busy = true;

        // Scripted characters overwrite the suffixes when
        // they're shown. So we want to manually reset them!
        PauseSubState.musicSuffix = '';
        GameOverSubState.musicSuffix = '';
        GameOverSubState.blueBallSuffix = '';

        WindowUtil.setWindowTitle('Friday Night Funkin\'');
        ModuleHandler.callEvent(new ScriptEvent(FS_EXITED_SUBSTATE));

        characterWheel.clear();
        iconGridTop.clear();
        iconGridBottom.clear();
        uiCamera.visible = false;
        _parentState.persistentUpdate = true;
        _parentState.persistentDraw = true;

        FlxTween.tween(blackBack, {x: -500}, 0.2, {ease: FlxEase.quintIn});
        FlxTween.tween(overlayShit, {x: FlxG.width}, 0.2, {ease: FlxEase.quintIn});
        FlxTween.tween(blackBack, {alpha: 0}, 0.2,
          {
            ease: FlxEase.quartIn,
            onComplete: function(twn:FlxTween) {
              close();
            }
          });
      }
    }

    if (!hotkeyBox.visible)
    {
      var leftPressed:Bool = controls.UI_LEFT;
      var rightPressed:Bool = controls.UI_RIGHT;
      var anyPressed:Bool = leftPressed || rightPressed;

      if (anyPressed)
      {
        if ((spamming && spamTimer >= 0.07) || (!spamming && spamTimer <= 0))
        {
          spamTimer = 0;

          if (leftPressed)
          {
            changeCharacter(-1);
          }
          else if (rightPressed)
          {
            changeCharacter(1);
          }
        }
        else if (!spamming && spamTimer >= 0.9)
        {
          spamming = true;
        }

        spamTimer += elapsed;
      }
      else
      {
        spamming = false;
        spamTimer = 0;
      }

      if (leftPressed) leftDifficultyArrow._asc.moveShitDown();
      if (rightPressed) rightDifficultyArrow._asc.moveShitDown();

      if (controls.FREEPLAY_LEFT || controls.FREEPLAY_RIGHT)
      {
        changePage(controls.FREEPLAY_LEFT ? -1 : 1);
      }

      // Mouse scrolling:
      // Up = Left
      // Down = Right
      if (FlxG.mouse.wheel < 0)
      {
        changeCharacter(1);
      }
      else if (FlxG.mouse.wheel > 0)
      {
        changeCharacter(-1);
      }

      if (controls.FREEPLAY_JUMP_TO_TOP)
      {
        changeCharacter(-currentCharacterIndex);
      }

      if (controls.FREEPLAY_JUMP_TO_BOTTOM)
      {
        if (!FS_SaveDataHandler.getSaveData().preferences.potatoMode)
        {
          changeCharacter(characterWheel.length - currentCharacterIndex);
        }
        else
        {
          changeCharacter(filteredKeys.indexOf(filteredKeys.length) - currentCharacterIndex);
        }
      }

      if (controls.FREEPLAY_CHAR_SELECT)
      {
        if (FS_SaveDataHandler.getSaveData().preferences.preferredSFX == "charSelect")
        {
          FunkinSound.playOnce(Paths.sound('CS_select'), 0.2);
        }
        else
        {
          FunkinSound.playOnce(Paths.sound('scrollMenu'), 0.4);
        }
        jumpToCurSelected();
      }

      if (controls.FREEPLAY_FAVORITE)
      {
        var shouldPlaySound:Bool = false;
        var saveObject:Dynamic = FS_SaveDataHandler.getSaveData();

        if (saveObject.characterIDs.bf != 'default')
        {
          saveObject.characterIDs.bf = 'default';
          shouldPlaySound = true;
        }
        if (saveObject.characterIDs.dad != 'default')
        {
          saveObject.characterIDs.dad = 'default';
          shouldPlaySound = true;
        }
        if (saveObject.characterIDs.gf != 'default')
        {
          saveObject.characterIDs.gf = 'default';
          shouldPlaySound = true;
        }
        if (shouldPlaySound)
        {
          FunkinSound.playOnce(Paths.sound('ranks/great'), 0.4);
          selected.visible = selectedTextVisibility();
          FS_SaveDataHandler.writeSaveData(saveObject);

          // Jump to default.
          jumpToCurSelected();
        }
      }

      if (controls.RESET)
      {
        hotkeyBox.visible = true;
        hotkeyBoxText.visible = true;
      }

      if (controls.DEBUG_MENU)
      {
        showVariations(currentCharacterID);
      }

      if (controls.ACCEPT)
      {
        var saveObject:Dynamic = FS_SaveDataHandler.getSaveData();
        var characterIDs:Dynamic = saveObject.characterIDs;
        var characterSlot:String = characterSlots[currentPageIndex][0];
        var savedCharacterID:String = ReflectUtil.getAnonymousField(characterIDs, characterSlot);
        var shouldConfirm:Bool = false;

        if (currentCharacterID != savedCharacterID)
        {
          if (!FS_CharacterDataHandler.lockedCharMap.exists(currentCharacterID))
          {
            var characterIDs:Dynamic = saveObject.characterIDs;
            var characterSlot:String = characterSlots[currentPageIndex][0];

            if (currentCharacterID != savedCharacterID)
            {
              ReflectUtil.setAnonymousField(characterIDs, characterSlot, currentCharacterID);
              shouldConfirm = true;
            }
          }
        }
        if (shouldConfirm)
        {
          confirmThing();
          selected.visible = selectedTextVisibility();
          newGraphic.visible = false;
          FS_SaveDataHandler.writeSaveData(saveObject);
        }
        else
        {
          if (FS_SaveDataHandler.getSaveData().preferences.preferredSFX == "charSelect")
          {
            FunkinSound.playOnce(Paths.sound('CS_locked'), 0.4);
          }
          else
          {
            FunkinSound.playOnce(Paths.sound('cancelMenu'));
          }
          flashScreen(0xFFFF0000, 0.03, 0.1);
          if (!FS_SaveDataHandler.getSaveData().preferences.potatoMode)
          {
            for (index in 0...characterWheel.members.length)
            {
              var item = characterWheel.members[index];
              if (item is FunkinSprite) item.animation.play('denied', true);
            }
          }
          else
          {
            if (lockedChill != null) lockedChill.playAnimation("clicked", true);
          }
        }
      }
    }
  }

  /**
   * Jumps to the currently selected character.
   */
  function jumpToCurSelected(jumpIn:Bool = false):Void
  {
    var saveObject:Dynamic = FS_SaveDataHandler.getSaveData();
    var characterIDs:Dynamic = saveObject.characterIDs;
    var characterSlot:String = characterSlots[currentPageIndex][0];
    var savedCharacterID:String = ReflectUtil.getAnonymousField(characterIDs, characterSlot);

    // In the event that the saved character ID no longer exists, we fallback to default.
    if (!FS_CharacterDataHandler.characterMap.exists(savedCharacterID) && savedCharacterID != 'default')
    {
      trace('[Funker Selector] Saved character ID doesn\'t exist! Resetting to default.');
      ReflectUtil.setAnonymousField(characterIDs, characterSlot, 'default');

      // Save everything
      FS_SaveDataHandler.writeSaveData(saveObject);
    }
    currentCharacterIndex = filteredKeys.indexOf(savedCharacterID);
    currentCharacterID = savedCharacterID;
    changeCharacter();
    updateCharInfo();

    // Play the jump in animation if we have it
    var characterSprite:FunkinSprite = FS_CharacterSpriteHandler.getCharacterSprite(currentCharacterID);
    if (characterSprite is BaseCharacter)
    {
      if (characterSprite.hasAnimation('fallin'))
      {
        characterSprite.ignoreExclusionPref.push('fallin');
        characterSprite.playAnimation('fallin', true, true);
      }
    }
  }

  /**
   * Called when the `ACCEPT` keybind is pressed.
   * Plays some effects.
   */
  function confirmThing():Void
  {
    if (FS_SaveDataHandler.getSaveData().preferences.preferredSFX == "charSelect")
    {
      FunkinSound.playOnce(Paths.sound('CS_confirm'), 0.4);
    }
    else
    {
      FunkinSound.playOnce(Paths.sound('confirmMenu'));
    }

    if (!FS_SaveDataHandler.getSaveData().preferences.potatoMode)
    {
      var fs_characterData:FS_characterData = FS_CharacterDataHandler.getCharacterData(currentCharacterID);
      var animation:String = fs_characterData.characterMenu.selectedAnim;
      var item:Dynamic = characterWheel.members[currentCharacterIndex];

      if (item != null)
      {
        if (item is Bopper)
        {
          item.playAnimation(animation, true, true);
          item.animation.onFinish.addOnce(function() {
            item.dance();
          });
        }
      }
    }

    if (currentCharacterIcon.hasAnimation('winning'))
    {
      currentCharacterIcon.playAnimation('winning');
    }

    flashScreen(0xFFFFFFFF, 0.03, 0.1);
  }

  /**
   * Displays the available character variations.
   * @param characterID The character ID we're using.
   */
  function showVariations(characterID:String):Void
  {
    var fs_characterData = FS_CharacterDataHandler.getCharacterData(characterID);
    var variationCount:Int = FS_CharacterDataHandler.getCharacterData(characterID, 1);
    var alertBody:String = "";

    if (variationCount <= 0) return;
    if (FS_CharacterDataHandler.lockedCharMap.exists(characterID)) return;
    if (characterID == 'default') return;

    for (variation in fs_characterData.characterVariations)
    {
      var characterName:String = "";
      var songNames:Array<String> = [];

      for (songID in variation.songID)
      {
        var songData:SongMetadata = SongRegistry.instance.parseEntryMetadata(songID, variation.songVariation);
        var characterData:CharacterData = CharacterDataParser.fetchCharacterData(variation.characterID);
        characterName = characterData?.name ?? "NONEXISTENT CHARACTER ID (" + variation.characterID + ")";
        songNames.push(songData?.songName ?? "NONEXISTENT SONG ID (" + songID + ")");
      }

      alertBody += "Name: " + characterName + "\n";
      alertBody += "Songs: " + songNames.join(", ");

      if (fs_characterData.characterVariations.indexOf(variation) < fs_characterData.characterVariations.length - 1)
      {
        alertBody += "\n\n";
      }
    }

    PolymodErrorHandler.showAlert("Available character variations", alertBody);
  }

  /**
   * Does a really fucking cool unlock animation.
   */
  function doUnlockAnimation(?skip:Bool):Void
  {
    if (!FS_SaveDataHandler.getSaveData().preferences.potatoMode)
    {
      for (index in 0...characterWheel.members.length)
      {
        var item = characterWheel.members[index];
        if (index == currentCharacterIndex && item is FunkinSprite)
        {
          lockedChill = item;
          break;
        }
      }
    }

    if (lockedChill is FunkinSprite)
    {
      lockedChill.animation.callback = function(name, frame) {
        if (name == 'death' && frame == 36)
        {
          finishUnlockAnim(false);
        }
      }
    }
    else
    {
      lockedChill.onAnimationFrame.add(function(name, frame) {
        if (name == 'unlock' && frame == 36)
        {
          finishUnlockAnim(true);
        }
      });
    }

    if (skip)
    {
      skipUnlockAnim(lockedChill);
      return;
    }

    if (FlxG.sound.music != null) FlxG.sound.music.fadeOut();

    if (!FS_SaveDataHandler.getSaveData().preferences.potatoMode)
    {
      lockedChill.offset.set();
      lockedChill.animation.play('idle', true);
    }
    else
    {
      lockedChill.playAnimation('idle', true);
    }

    FlxTween.tween(uiCamera, {alpha: 0}, 1,
      {
        ease: FlxEase.quartOut,
        onComplete: function(twn:FlxTween) {
          unlockSound.play(true);
          new FlxTimer().start(1.45, function() {
            if (!FS_SaveDataHandler.getSaveData().preferences.potatoMode)
            {
              lockedChill.offset.set(170, 220);
              lockedChill.animation.play('death');
            }
            else
            {
              lockedChill.playAnimation('unlock');
            }
          });
        }
      });
  }

  /**
   * Replaces and updates the Character.
   */
  function finishUnlockAnim(simplifyUI:Bool):Void
  {
    flashScreen(0xFFFFFFFF, 0.05, 1);
    new FlxTimer().start(0.025, function() {
      updateCharInfo();
      if (selected.visible) selected.visible = false;
      newGraphic.visible = true;
      uiCamera.shake(0.01, 0.2);
      FlxG.state.subState.funnyCam.shake(0.01, 0.2);
    });

    if (!simplifyUI)
    {
      fs_characterData = FS_CharacterDataHandler.getCharacterData(currentCharacterID);
      characterWheel.replace(lockedChill, FS_CharacterSpriteHandler.getCharacterSprite(currentCharacterID));
    }

    busy = false;
    uiCamera.alpha = 1;

    if (FlxG.sound.music != null) FlxG.sound.music.fadeIn(2, 0, 0.8);
  }

  /**
   * Skips the unlock animation.
   */
  function skipUnlockAnim(lockedChill:Dynamic):Void
  {
    if (lockedChill is FunkinSprite)
    {
      lockedChill.offset.set(170, 220);
      lockedChill.animation.play('death');
      lockedChill.animation.pause();
      lockedChill.animation.curAnim.curFrame = 36;
      lockedChill.animation.resume();

      if (FS_SaveDataHandler.getSaveData().preferences.preferredSFX == "charSelect")
      {
        FunkinSound.playOnce(Paths.sound('CS_confirm'), 0.4);
      }
      else
      {
        FunkinSound.playOnce(Paths.sound('confirmMenu'));
      }
    }
    else
    {
      lockedChill.playAnimation('unlock');
      lockedChill.anim.pause();
      lockedChill.anim.curFrame = 34;
      lockedChill.anim.resume();

      if (FS_SaveDataHandler.getSaveData().preferences.preferredSFX == "charSelect")
      {
        FunkinSound.playOnce(Paths.sound('CS_confirm'), 0.4);
      }
      else
      {
        FunkinSound.playOnce(Paths.sound('confirmMenu'));
      }
    }
  }

  /**
   * Adjusts the description size relative to the description text box.
   * @param characterDescription The `characterDescription` FlxText object.
   */
  function adjustFontSize(characterDescription:FlxText):Void
  {
    if (characterDescription == null) return;
    var currentFontSize = characterDescription.size;
    var maxHeight = blackBack.height - 400;
    if (characterDescription.fieldHeight > maxHeight)
    {
      currentFontSize--;

      characterDescription.size = currentFontSize;
      characterDescription.letterSpacing -= 0.16 * (currentFontSize / 10);

      if (currentFontSize <= 8) return;
    }
  }

  /**
   * Update character information.
   */
  function updateCharInfo():Void
  {
    var variationCount:Int = 0;

    selectText.text = topText[currentPageIndex];
    selectText.color = topTextColor[currentPageIndex];
    selectText.screenCenter(0x01);
    selectText.x -= 330;
    selected.visible = selectedTextVisibility();

    newGraphic.visible = false;

    if (currentCharacterID != 'default')
    {
      fs_characterData = FS_CharacterDataHandler.getCharacterData(currentCharacterID);
      characterData = CharacterDataParser.fetchCharacterData(currentCharacterID);
      variationCount = FS_CharacterDataHandler.getCharacterData(currentCharacterID, 1);
    }

    switch (currentCharacterID)
    {
      case 'default':
        currentCharacterIcon.configure('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');
        characterName.text = "DEFAULT";
        descriptionText = "This is the Default character defined by the song.";

        FlxSpriteUtil.fill(overlayShit, getDominantColor(currentCharacterIcon, 0.5, 0.7));
      default:
        if (FS_CharacterDataHandler.lockedCharMap.exists(currentCharacterID))
        {
          characterName.text = "LOCKED";

          var unlockHint = "\n\nUnlock Condition: " + fs_characterData.description.unlockCondition;

          descriptionText = "This character is locked! I wonder who it could be..." + unlockHint;

          FlxSpriteUtil.fill(overlayShit, 0xB3B8B8B8);
        }
        else
        {
          characterName.text = characterData?.name;
          currentCharacterIcon.configure(characterData?.healthIcon);
          currentCharacterIcon.size.set(1.2, 1.2);
          currentCharacterIcon.setPosition(150, 100);

          descriptionText = fs_characterData.description.text;

          FlxSpriteUtil.fill(overlayShit, getDominantColor(currentCharacterIcon, 0.5, 0.7));
        }
    }

    // Reset the description size and letter spacing.
    characterDescription.size = 35;
    characterDescription.letterSpacing = 0;

    characterDescription.resetText(descriptionText);
    characterDescription.start(0.01);

    // Making it not look so awkward when "Simplify UI" is turned on.
    if (FS_SaveDataHandler.getSaveData().preferences.potatoMode || currentCharacterID == 'default')
    {
      currentCharacterIcon.setPosition(750, 250);
      currentCharacterIcon.size.set(1.7, 1.7);
    }

    if (!FS_SaveDataHandler.getSaveData().preferences.potatoMode)
    {
      for (icon in iconGridTop)
      {
        if (currentCharacterID == 'default' || FS_CharacterDataHandler.lockedCharMap.exists(currentCharacterID))
        {
          icon.configure('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');
        }
        else if (icon.characterId != characterData?.healthIcon.id)
        {
          icon.configure(characterData?.healthIcon);
        }
      }

      for (icon in iconGridBottom)
      {
        if (currentCharacterID == 'default' || FS_CharacterDataHandler.lockedCharMap.exists(currentCharacterID))
        {
          icon.configure('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');
        }
        else if (icon.characterId != characterData?.healthIcon.id)
        {
          icon.configure(characterData?.healthIcon);
        }
      }
    }

    variationText.screenCenter(0x01);
    variationText.x += 220;
    variationText.text = "This character has " + variationCount + " available " + (variationCount == 1 ? "variation" : "variations");

    if (variationCount > 0 && !FS_CharacterDataHandler.lockedCharMap.exists(currentCharacterID))
    {
      trace("[Funker Selector] Variations found for character ID " + currentCharacterID);
      variationText.visible = true;
    }
    else
    {
      variationText.visible = false;
    }

    if (FS_CharacterDataHandler.lockedCharMap.exists(currentCharacterID))
    {
      if (currentCharacterIcon != null) currentCharacterIcon.visible = false;
      if (FS_SaveDataHandler.getSaveData().preferences.potatoMode) lockedChill.visible = true;
    }
    else
    {
      if (currentCharacterIcon != null) currentCharacterIcon.visible = true;
      if (FS_SaveDataHandler.getSaveData().preferences.potatoMode) lockedChill.visible = false;
    }

    characterName.screenCenter(0x01);
    characterName.x += 220;

    // Do the unlock animation if we haven't seen it yet.
    if (FS_CharacterDataHandler.lockedCharMap.exists(currentCharacterID)
      && FS_CharacterDataHandler.isCharacterUnlocked(currentCharacterID, fs_characterData.unlockMethod))
    {
      var saveObject:Dynamic = FS_SaveDataHandler.getSaveData();

      if (!saveObject.seenUnlocks.contains(currentCharacterID))
      {
        FS_CharacterDataHandler.lockedCharMap.remove(currentCharacterID);
        saveObject.seenUnlocks.push(currentCharacterID);

        FS_SaveDataHandler.writeSaveData(saveObject);

        busy = true;
        doUnlockAnimation(FlxG.keys.pressed.SHIFT);
      }
    }
  }

  /**
   * HELPER FUNCTIONS
   * These are functions that are simply nice to have. They make the code cleaner.
   */
  /**
   * Something.
   * @return Whether it's the selected character.
   */
  function selectedTextVisibility():Bool
  {
    var characterIDs:Dynamic = FS_SaveDataHandler.getSaveData().characterIDs;
    var characterSlot:String = characterSlots[currentPageIndex][0];

    return currentCharacterID == ReflectUtil.getAnonymousField(characterIDs, characterSlot);
  }

  /**
   * Helper function for configuring a FlxText
   * @param object The FlxText object
   * @param text The text itself
   * @param offsets The offsets as an array
   * @param size The size of the text
   * @param font The font
   * @return A FlxText object
   */
  function configureText(object:FlxText, ?text:String, ?offsets:Array<Int>, ?size:Int, ?font:String, ?alignment:String, ?typeText:Bool):FlxText
  {
    if (text == null) text = "";
    if (offsets == null) offsets = [0, 0];
    if (size == null) size = 35;

    if (object == null)
    {
      if (typeText)
      {
        object = new FlxTypeText(0, 0, 0, "PLACEHOLDER");
      }
      else
      {
        object = new FlxText(0, 0, 0, "PLACEHOLDER");
      }
    }

    object.text = text;
    object.x += offsets[0];
    object.y += offsets[1];

    if (font != null)
    {
      object.setFormat(font, size, null, alignment ?? 'center', FlxTextBorderStyle.OUTLINE, 0xFF000000);
      object.borderSize = 2.5;
    }

    return object;
  }

  /**
   * Gets the dominant color of a `FunkinSprite`.
   * Taken from this mod: https://gamebanana.com/mods/511342
   * @param sprite The `FunkinSprite` to get the dominant color of.
   * @return The dominant color of the sprite.
   */
  function getDominantColor(sprite:FunkinSprite, ?resMult:Float = 1.0, alpha:Float = 1.0):Int
  {
    var mult:Float = Math.min(1, (150 / sprite.frameWidth) * resMult);
    var countByColor:Array<Int> = [];
    var colorById:Array<Int> = [];
    for (col in 0...(sprite.frameWidth) * mult)
    {
      for (row in 0...(sprite.frameHeight) * mult)
      {
        var colorOfThisPixel:Int = sprite.pixels.getPixel32(col / mult, row / mult);
        if (colorOfThisPixel != 0)
        {
          var colorId = colorById.indexOf(colorOfThisPixel);
          if (colorId != -1)
          {
            countByColor[colorId] = countByColor[colorId] + 1;
          }
          else
          {
            var id = colorById.length;
            colorById[id] = colorOfThisPixel;
            countByColor[id] = 1;
          }
        }
      }
    }

    var maxCount:Int = 0;
    var maxKey:Int = 0;
    for (color in colorById)
    {
      var id = colorById.indexOf(color);
      var count = countByColor[id] != null ? countByColor[id] : 0;
      if (id != -1 && count > maxCount && color != 0xFF000000 && color != 0x00FFFFFF)
      {
        var alphaChannel = (color >> 24) & 0xff;
        if (alphaChannel >= 255)
        {
          maxCount = count;
          maxKey = color;
        }
      }
    }

    var newAlpha = Std.int(Math.max(0, Math.min(1, alpha)) * 255);
    return (maxKey & 0x00FFFFFF) | (newAlpha << 24);
  }
}
