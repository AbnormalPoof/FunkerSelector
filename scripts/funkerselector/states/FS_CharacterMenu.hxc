import Array;
import Std;
import haxe.Json;
import haxe.ds.ObjectMap;
import haxe.ds.StringMap;
import lime.app.Application;
import flixel.FlxG;
import flixel.addons.text.FlxTypeText;
import flixel.group.FlxTypedGroup;
import flixel.text.FlxText;
import flixel.tweens.FlxEase;
import flixel.tweens.FlxTween;
import flixel.util.FlxTimer;
import funkin.audio.FunkinSound;
import funkin.data.animation.AnimationDataUtil;
import funkin.data.freeplay.player.PlayerRegistry;
import funkin.data.song.SongRegistry;
import funkin.graphics.FunkinCamera;
import funkin.graphics.FunkinSprite;
import funkin.modding.PolymodErrorHandler;
import funkin.modding.events.ScriptEvent;
import funkin.modding.module.ModuleHandler;
import funkin.play.GameOverSubState;
import funkin.play.PauseSubState;
import funkin.play.character.BaseCharacter;
import funkin.play.character.CharacterDataParser;
import funkin.play.components.HealthIcon;
import funkin.play.stage.Bopper;
import funkin.save.Save;
import funkin.ui.MusicBeatSubState;
import funkin.ui.charSelect.Lock;
import funkin.ui.freeplay.charselect.PlayableCharacter;
import funkin.util.Constants;
import funkin.util.MathUtil;
import funkin.util.ReflectUtil;
import funkin.util.SortUtil;
import funkin.util.WindowUtil;
import funkin.util.assets.DataAssets;
import funkin.util.assets.FlxAnimationUtil;
import funkin.util.tools.IteratorTools;

/**
 * This is a substate that acts as a Character Selection screen.
 */
class FS_CharacterMenu extends MusicBeatSubState
{
  /**
   * The character name, displayed at the top of the screen.
   */
  var characterName:FlxText;

  /**
   * A list of character variations. Used in the pop-up when selecting the `DEBUG_MENU` keybind.
   */
  var variationText:FlxText;

  /**
   * An indicator that the current character is selected.
   */
  var selected:FlxText;

  /**
   * A counter that shows the current character's index, and the total amount of characters.
   * Displayed as "< current / total >".
   */
  var characterCount:FlxText;

  /**
   * The text used in the loading screen.
   */
  var loadingText:FlxText;

  /**
   * The character's description. This is a `FlxTypeText` for the typewriter effect.
   * This is automatically resized to fit inside `descriptionBox`.
   */
  var characterDescription:FlxTypeText;

  /**
   * The character's description text, grabbed from the character's JSON.
   */
  var descriptionText:String;

  /**
   * A box where all the hotkeys are displayed.
   */
  var hotkeyBox:FunkinSprite;

  /**
   * The left difficulty arrow.
   */
  var leftDifficultyArrow:FunkinSprite;

  /**
   * The right difficulty arrow.
   */
  var rightDifficultyArrow:FunkinSprite;

  /**
   * A box where the character description is displayed.
   */
  var descriptionBox:FunkinSprite;

  /**
   * Stolen from `FreeplayState` LMAO
   */
  var newGraphic:FunkinSprite;

  /**
   * NOTE: This is either a `FunkinSprite`, or a `Lock`
   * depending on if "Simplify UI" is enabled or not.
   */
  var lockedChill:Null;

  /**
   * The unlock sound that plays during the unlock animation.
   */
  var unlockSound:FunkinSound;

  /**
   * The camera for certain UI elements.
   */
  var uiCamera:FunkinCamera;

  /**
   * The camera for sprites.
   */
  var spriteCamera:FunkinCamera;

  /**
   * A map containing every character.
   */
  var characterMap:StringMap<String, Array<String, String>> = ModuleHandler.getModule("FS_CharacterDataHandler").scriptGet('characterMap');

  /**
   * A filtered character array for the current page.
   * We still use this array since `FS_CharacterMenu` is built around Arrays.
   */
  var filteredKeys:Array<String> = [];

  /**
   * The save data for Funker Selector.
   */
  var saveData:Dynamic = ModuleHandler.getModule("FS_SaveDataHandler").scriptCall('getSaveData');

  /**
   * A map of all the locked characters.
   */
  var lockedCharMap:StringMap<String> = ModuleHandler.getModule("FS_CharacterDataHandler").scriptGet('lockedCharMap');

  /**
   * A map of `Boppers`.
   * This is used for the character wheel.
   */
  var bopperCharacterIDs:ObjectMap<Bopper, String> = new ObjectMap();

  /**
   * The JSON character cache, which is retrieved from `FS_CoreModule`.
   */
  var jsonCharacterCache:StringMap<String, Array<Dynamic, Dynamic>, Array> = ModuleHandler.getModule("FS_CharacterDataHandler")
    .scriptGet('jsonCharacterCache');

  /**
   * For the top text in the menu.
   * These alternate depending on the page.
   */
  var topText:Array<String> = ["PLAYABLE CHARACTERS", "OPPONENT CHARACTERS", "SPEAKER CHARACTERS"];

  /**
   * The color of the top text.
   * These alternate depending on the page.
   */
  var topTextColor:Array<FlxColor> = [0xFF2DB2D2, 0xFFAF66CE, 0xFFA7004C];

  /**
   * Character slots in the order of "PLAYABLE CHARACTERS", "OPPONENT CHARACTERS", and "SPEAKER CHARACTERS".
   * These are an array of arrays, they can have multiple aliases for better flexibility.
   *
   * `pageIndex` uses this to determine which page is currently selected.
   */
  var characterSlots:Array<String> = [['bf', 'player'], ['dad', 'opponent'], ['gf', 'speaker']];

  /**
   * Stuff related to the icon grid.
   */
  var currentCharacterIcon:HealthIcon;

  /**
   * An array of `HealthIcon`s used for the icon grid.
   */
  var iconGrid:Array<HealthIcon> = [];

  /**
   * The index of the currently selected character.
   */
  var currentCharacterIndex:Int = 0;

  /**
   * The index of the current page.
   */
  var currentPageIndex:Int = 0;

  /**
   * This is a `FlxTypedGroup` for the character wheel.
   * This is a bit janky but it works so whatever.
   */
  var characterWheel:FlxTypedGroup<BaseCharacter> = new FlxTypedGroup();

  /**
   * The current song BPM in Freeplay.
   */
  var songBPM:Float = null;

  /**
   * The current character ID.
   */
  var currentCharacterID:String = 'default';

  /**
   * If enabled, the menu will stop responding to inputs.
   * This is used for the unlock animation
   */
  var busy:Bool = false;

  /**
   * Script Event called when this SubState is opened.
   */
  var FS_OPENED_SUBSTATE:String = "FS_OPENED_SUBSTATE";

  /**
   * Script Event called when this SubState is closed.
   */
  var FS_EXITED_SUBSTATE:String = "FS_EXITED_SUBSTATE";

  /**
   * The base scroll speed for the icon grid.
   */
  var ICON_SCROLL_SPEED:Float = 0.3;

  /**
   * Stolen from `FreeplayState`.
   */
  var spamTimer:Float = 0;

  /**
   * Stolen from `FreeplayState`.
   */
  var spamming:Bool = false;

  /**
   * MODULES
   * These are modules that are called throughout the menu.
   */
  /**
   * The `FS_CharacterDataHandler` module.
   */
  var FS_CharacterDataHandler:Module = ModuleHandler.getModule("FS_CharacterDataHandler");

  /**
   * The `FS_SaveDataHandler` module.
   */
  var FS_SaveDataHandler:Module = ModuleHandler.getModule("FS_SaveDataHandler");

  public function new(songBPM:Float)
  {
    super();

    this.songBPM = songBPM;
  }

  public override function create():Void
  {
    super.create();

    setupUIStuff();
    updateFilteredKeys();

    if (!saveData.preferences.potatoMode)
    {
      loadingText.visible = true;
      uiCamera.visible = false;
      FlxTween.tween(bg, {alpha: 0.5}, 0.05,
        {
          ease: FlxEase.quartOut,
          onComplete: function(twn:FlxTween) {
            createIconGrid(150, 0.2);
            buildCharacterWheel();
            jumpToCurSelected();
          }
        });
    }
    else
    {
      FlxTween.tween(bg, {alpha: 0.5}, 0.05, {ease: FlxEase.quartOut});
      jumpToCurSelected();
    }
    ModuleHandler.callEvent(new ScriptEvent(FS_OPENED_SUBSTATE));
  }

  public override function update(elapsed:Float):Void
  {
    super.update(elapsed);

    conductorInUse.update();

    adjustFontSize(characterDescription ?? null);

    // Adding some useful stuff to the variable watch window.
    if (Constants.DEBUG_BUILD)
    {
      FlxG.watch.addQuick("currentPageIndex", currentPageIndex);
      FlxG.watch.addQuick("currentCharacterIndex", currentCharacterIndex);
      FlxG.watch.addQuick("currentCharacterID", currentCharacterID);
      FlxG.watch.addQuick("filteredKeys", filteredKeys);
      FlxG.watch.addQuick("bf", FS_SaveDataHandler.scriptCall('getSaveData').characterIDs.bf);
      FlxG.watch.addQuick("gf", FS_SaveDataHandler.scriptCall('getSaveData').characterIDs.gf);
      FlxG.watch.addQuick("dad", FS_SaveDataHandler.scriptCall('getSaveData').characterIDs.dad);
    }

    if (!busy) handleKeyShit();

    for (icon in iconGrid)
    {
      var speedFactor:Float = (Math.min(conductorInUse.bpm, 300) / 60) * (FlxG.elapsed / (1 / FlxG.drawFramerate));

      icon.x -= ICON_SCROLL_SPEED * speedFactor;
      icon.y += (ICON_SCROLL_SPEED * speedFactor) / 2; // Vertical speed is halved.

      if (icon.x < -icon.width)
      {
        icon.x += (FlxG.width + icon.width) + 70;
      }

      if (icon.y > FlxG.height)
      {
        icon.y -= (FlxG.height + icon.height) + 30;
      }
    }

    if (!saveData.preferences.potatoMode)
    {
      for (index in 0...characterWheel.members.length)
      {
        var item:Dynamic = characterWheel.members[index];
        var characterID:String = bopperCharacterIDs.exists(item) ? bopperCharacterIDs.get(item) : item.characterId;
        if (item == null) continue;
        fs_characterData = FS_CharacterDataHandler.scriptCall('getCharacterData', [characterID]);

        var xOffset:Float = fs_characterData.characterMenu.position[0];
        var baseX:Float = (index - (currentCharacterIndex - 1)) * 550;
        var targetX:Float = baseX + xOffset + 250;

        item.x = MathUtil.smoothLerp(item.x, targetX, elapsed, 0.20);
      }
    }

    if (uiCamera != null)
    {
      uiCamera.zoom = MathUtil.smoothLerp(uiCamera.zoom, 1, elapsed, 0.45);
    }
  }

  function buildCharacterWheel():Void
  {
    characterWheel.clear();

    for (characterIndex in 0...filteredKeys.length)
    {
      var characterID:String = filteredKeys[characterIndex];
      var characterSprite:Bopper;
      var lockedChill:FunkinSprite;

      if (characterID != 'default')
      {
        fs_characterData = FS_CharacterDataHandler.scriptCall('getCharacterData', [characterID]);
        characterSprite = buildCharacterSprite(fs_characterData);
      }

      if (characterSprite != null)
      {
        if (lockedCharMap.exists(characterID))
        {
          lockedChill = FunkinSprite.createSparrow(200, 250, 'funkerSelector/locked_character');
          lockedChill.animation.addByPrefix('idle', 'LOCKED MAN0', 24, false);
          lockedChill.animation.addByPrefix('denied', 'cannot select0', 24, false);
          lockedChill.animation.addByPrefix('death', 'locked man explodes0', 24, false);
          lockedChill.animation.play('idle');
          lockedChill.animation.finishCallback = function(_) {
            lockedChill.offset.set();
            lockedChill.animation.play('idle');
          };
          lockedChill.scale.set(1.2, 1.2);
          lockedChill.camera = spriteCamera;
          characterWheel.add(lockedChill);
        }
        else
        {
          trace("[Funker Selector] Configuring sprite...");
          characterWheel.add(characterSprite);
        }
      }
      else
      {
        characterWheel.add(null);
      }
    }

    loadingText.visible = false;
    uiCamera.visible = true;

    refresh();
    changeCharacter();
  }

  function buildCharacterSprite(data:FS_characterData):FunkinSprite
  {
    var baseCharacter:BaseCharacter = CharacterDataParser.fetchCharacter(data.characterID);

    if (data.characterMenu.useCustomSprites && data.characterMenu.customSpriteData != null)
    {
      var animationData:Array<Dynamic> = data.characterMenu.customSpriteData.animations;
      characterSprite = new Bopper(data.characterMenu.customSpriteData?.danceEvery ?? 1.0);
      characterSprite.loadSparrow(data.characterMenu.customSpriteData.assetPath);
      FlxAnimationUtil.addAtlasAnimations(characterSprite, animationData);
      for (animation in data.characterMenu.customSpriteData?.animations)
      {
        characterSprite.setAnimationOffsets(animation.name, animation.offsets[0], animation.offsets[1]);
      }
      bopperCharacterIDs.set(characterSprite, data.characterID);
      characterSprite.playAnimation(data.characterMenu.customSpriteData?.startingAnimation ?? 'idle');
      configureCharacterSprite(characterSprite, data);
      return characterSprite;
    }
    else if (baseCharacter != null)
    {
      configureCharacterSprite(baseCharacter, data);
      return baseCharacter;
    }
    else
    {
      return null;
    }
  }

  /**
   * Stolen from `StoryMenuState.hx` LOL
   *
   * Changes the selected character.
   * @param change +1 (right), -1 (left)
   */
  function changeCharacter(change:Int = 0):Void
  {
    var prevIndex:Int = currentCharacterIndex;
    currentCharacterIndex = (prevIndex + (change + filteredKeys.length)) % filteredKeys.length;

    currentCharacterID = filteredKeys[currentCharacterIndex];

    if (!saveData.preferences.potatoMode)
    {
      for (index in 0...characterWheel.members.length)
      {
        var item:Dynamic = characterWheel.members[index];

        if (index == currentCharacterIndex - 1)
        {
          item.alpha = 1.0;
          if (item.animation?.paused) item.animation.resume();
        }
        else
        {
          item.alpha = 0.5;
          if (item.animation?.curAnim?.looped) item.animation.pause();
        }
      }
    }

    if (currentCharacterIndex != prevIndex)
    {
      if (saveData.preferences.preferredSFX == "charSelect")
      {
        FunkinSound.playOnce(Paths.sound('CS_select'), 0.2);
      }
      else
      {
        FunkinSound.playOnce(Paths.sound('scrollMenu'), 0.4);
      }
    }

    updateCharInfo();

    characterCount.text = "< " + (currentCharacterIndex + 1) + " / " + filteredKeys.length + " >";
    characterCount.screenCenter(0x01);
  }

  /**
   * Changes the current page.
   * @param change +1 (right), -1 (left)
   */
  function changePage(change:Int = 0):Void
  {
    var prevIndex:Int = currentPageIndex;
    currentPageIndex = (prevIndex + (change + characterSlots.length)) % characterSlots.length;

    // Reset currentCharacterIndex
    currentCharacterIndex = 0;

    updateFilteredKeys();
    if (!saveData.preferences.potatoMode)
    {
      buildCharacterWheel();
    }
    changeCharacter();
  }

  function beatHit():Void
  {
    bopDaThing();
    if (!saveData.preferences.potatoMode)
    {
      for (index in 0...characterWheel.members.length)
      {
        var item:Dynamic = characterWheel.members[index];
        if (index == currentCharacterIndex - 1)
        {
          if (item is Bopper)
          {
            item.dance();
          }
        }
      }
    }

    if (conductorInUse.currentBeat % 4 == 0)
    {
      if (uiCamera != null)
      {
        FlxTween.tween(uiCamera, {zoom: 1.02}, 0.01, {ease: FlxEase.quartOut});
      }
    }
  }

  /**
   * Updates the `filteredKeys` array based on the current `currentPageIndex`.
   */
  function updateFilteredKeys():Void
  {
    trace('[Funker Selector] Sorting the Character Map...');

    filteredKeys = IteratorTools.array(characterMap.keys()).filter(function(shit) {
      characterType = characterMap[shit][1];
      var types:Array<String> = (characterType is Array) ? characterType : [characterType];

      for (pageType in characterSlots[currentPageIndex])
      {
        if (types.contains(pageType))
        {
          return true;
        }
      }
      return false;
    });

    filteredKeys.sort(function(a:String, b:String):Int {
      characterDataA = CharacterDataParser.fetchCharacterData(a);
      characterDataB = CharacterDataParser.fetchCharacterData(b);

      return SortUtil.alphabetically(characterDataA?.name, characterDataB?.name);
    });

    filteredKeys.insert(0, 'default');

    trace("[Funker Selector] Updated the character list:\n" + filteredKeys);
  }

  /**
   * Make a super awesome cool icon grid!
   * @param spacing The spacing of the icons, I guess.
   *
   * This is disabled if "Simplify UI" is turned on in the Options Menu.
   */
  function createIconGrid(spacing:Int, ?alpha:Float = 0.2):Void
  {
    var characterData = CharacterDataParser.fetchCharacterData(currentCharacterID);
    var columns = Math.ceil(FlxG.width / (spacing * 2));
    var rows = Math.ceil(FlxG.height / (spacing * 2));
    var xStart = (FlxG.width - columns * spacing * 2) / 2;
    var yStart = (FlxG.height - rows * spacing * 2) / 2;

    for (i in 0...rows)
    {
      for (j in 0...columns)
      {
        for (k in 0...2)
        {
          for (l in 0...2)
          {
            var icon = new HealthIcon('dad', 0);
            icon.x = xStart + (j * 2 + k) * spacing;
            icon.y = yStart + (i * 2 + l) * spacing;
            icon.alpha = alpha;
            icon.zIndex = 200;

            icon.configure(characterData?.healthIcon ?? 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');

            add(icon);
            iconGrid.push(icon);
            icon.camera = spriteCamera;
          }
        }
      }
    }
  }

  /**
   * Configuring the JSON character, setting up position, scale, flipping, etc.
   * @param characterSprite The BaseCharacter to configure.
   * @param data The character data to use.
   * @return The configured BaseCharacter.
   */
  function configureCharacterSprite(characterSprite:FunkinSprite, data:Dynamic):FunkinSprite
  {
    if (data == null)
    {
      trace('[Funker Selector] ERROR: Data is null! Can\'t configure characterSprite.');
      return;
    }
    var funkin_characterData:CharacterData = CharacterDataParser.fetchCharacterData(data.characterID);
    var scaleFactor:Float = data.characterMenu.scale * (funkin_characterData?.isPixel ? 6 : 1);

    characterSprite.y += data.characterMenu.position[1];
    characterSprite.flipX = data.characterMenu.flipX;
    if (characterSprite is BaseCharacter)
    {
      characterSprite.setScale(scaleFactor);
    }
    else
    {
      characterSprite.scale.set(scaleFactor, scaleFactor);
    }
    characterSprite.antialiasing = !funkin_characterData?.isPixel ? true : false;
    characterSprite.pixelPerfectRender = funkin_characterData?.isPixel;
    characterSprite.camera = spriteCamera;

    return characterSprite;
  }

  /**
   * Set up UI stuff like the BG and text.
   */
  function setupUIStuff():Void
  {
    spriteCamera = new FunkinCamera('UISprites');
    FlxG.cameras.add(spriteCamera, false);
    spriteCamera.bgColor = 0x0;

    uiCamera = new FunkinCamera('UIElements');
    FlxG.cameras.add(uiCamera, false);
    uiCamera.bgColor = 0x0;

    bg = new FunkinSprite(0, 0);
    bg.makeSolidColor(FlxG.width, FlxG.height, 0xFF000000);
    bg.alpha = 0;
    bg.zIndex = 100;
    bg.camera = spriteCamera;
    add(bg);

    selectText = configureText(null, null, [170, 10], 50, Paths.font("PhantomMuff.ttf"));
    selectText.screenCenter(0x01);
    selectText.zIndex = 300;
    selectText.camera = uiCamera;
    add(selectText);

    characterCount = configureText(null, null, [170, 60], 45, Paths.font("PhantomMuff.ttf"));
    characterCount.color = 0xFFE3E1E1;
    characterCount.zIndex = 300;
    characterCount.camera = uiCamera;
    add(characterCount);

    characterDescription = configureText(null, "PLACEHOLDER", [250, 510], null, Paths.font("PhantomMuff.ttf"), true);
    characterDescription.wordWrap = true;
    characterDescription.fieldWidth = 800;
    characterDescription.zIndex = 400;
    characterDescription.camera = uiCamera;
    add(characterDescription);

    selected = configureText(null, '(SELECTED)', [720, 220], 50, Paths.font("PhantomMuff.ttf"));
    selected.color = 0xFF53FF38;
    selected.visible = false;
    selected.zIndex = 400;
    selected.camera = uiCamera;
    add(selected);

    hotkeyBox = new FunkinSprite(0, 0);
    hotkeyBox.makeSolidColor(600, 600, 0xFF000000);
    hotkeyBox.camera = uiCamera;
    hotkeyBox.alpha = 0.8;
    hotkeyBox.zIndex = 500;
    hotkeyBox.screenCenter();
    hotkeyBox.visible = false;
    add(hotkeyBox);

    hotkeyHintText = configureText(null, controls.getDialogueNameFromToken("RESET", true) + ' - Hotkeys', [990, 15], 45, Paths.font("PhantomMuff.ttf"));
    hotkeyHintText.color = 0xFFE3E1E1;
    hotkeyHintText.camera = uiCamera;
    hotkeyHintText.zIndex = 300;
    add(hotkeyHintText);

    hotkeyBoxText = configureText(null,
      controls.getDialogueNameFromToken("FREEPLAY_FAVORITE", true)
      + ' - Reset everything to default.\n\n'
      + controls.getDialogueNameFromToken("FREEPLAY_CHAR_SELECT", true)
      + ' - Jump to the currently selected character.\n\n'
      + controls.getDialogueNameFromToken("FREEPLAY_LEFT", true)
      + ' - Switch to the previous page.\n\n'
      + controls.getDialogueNameFromToken("FREEPLAY_RIGHT", true)
      + ' - Switch to the next page.\n\n'
      + controls.getDialogueNameFromToken("BACK", true)
      + ' - Close this.\n\n'
      + controls.getDialogueNameFromToken("DEBUG_MENU", true)
      + ' - Show available character variations.',
      [350, 100], 35, Paths.font("PhantomMuff.ttf"));
    hotkeyBoxText.camera = uiCamera;
    hotkeyBoxText.wordWrap = true;
    hotkeyBoxText.visible = false;
    hotkeyBoxText.fieldWidth = 600;
    hotkeyBoxText.zIndex = 600;
    add(hotkeyBoxText);

    characterName = configureText(null, null, [170, 110], 70, Paths.font("PhantomMuff.ttf"));
    characterName.camera = uiCamera;
    characterName.zIndex = 300;
    add(characterName);

    variationText = configureText(null, null, [170, 180], 35, Paths.font("PhantomMuff.ttf"));
    variationText.color = 0xFFFF8F2E;
    variationText.camera = uiCamera;
    variationText.zIndex = 300;
    add(variationText);

    leftDifficultyArrow = FunkinSprite.createSparrow(20, 300, 'storymenu/ui/arrows');
    leftDifficultyArrow.animation.addByPrefix('idle', 'leftIdle0');
    leftDifficultyArrow.animation.addByPrefix('press', 'leftConfirm0');
    leftDifficultyArrow.animation.play('idle');
    leftDifficultyArrow.scale.set(1.5, 1.5);
    leftDifficultyArrow.camera = uiCamera;
    leftDifficultyArrow.zIndex = 500;
    leftDifficultyArrow.updateHitbox();
    add(leftDifficultyArrow);

    rightDifficultyArrow = FunkinSprite.createSparrow(1200, leftDifficultyArrow.y, 'storymenu/ui/arrows');
    rightDifficultyArrow.animation.addByPrefix('idle', 'rightIdle0');
    rightDifficultyArrow.animation.addByPrefix('press', 'rightConfirm0');
    rightDifficultyArrow.animation.play('idle');
    rightDifficultyArrow.scale.set(1.5, 1.5);
    rightDifficultyArrow.camera = uiCamera;
    rightDifficultyArrow.zIndex = 500;
    rightDifficultyArrow.updateHitbox();
    add(rightDifficultyArrow);

    if (saveData.preferences.potatoMode)
    {
      lockedChill = new Lock(530, 270, FlxG.random.int(1, 9));
      lockedChill.onAnimationComplete.add(function(name) {
        if (name != 'selected') lockedChill.playAnimation('selected');
      });
      lockedChill.playAnimation('selected');
      lockedChill.scale.set(2, 2);
      lockedChill.camera = uiCamera;
      lockedChill.zIndex = 300;
      lockedChill.visible = false;
      lockedChill.updateHitbox();
      add(lockedChill);
    }
    else
    {
      characterWheel.zIndex = 250;
      add(characterWheel);

      loadingText = configureText(null, "LOADING\nPLEASE WAIT", [170, 10], 50, Paths.font("PhantomMuff.ttf"));
      loadingText.screenCenter();
      loadingText.camera = spriteCamera;
      loadingText.zIndex = 300;
      loadingText.visible = false;
      add(loadingText);
    }

    newGraphic = FunkinSprite.createSparrow(840, 460, 'freeplay/freeplayCapsule/new');
    newGraphic.animation.addByPrefix('new', 'NEW notif', 24);
    newGraphic.animation.play('new');
    newGraphic.camera = uiCamera;
    newGraphic.scale.set(1.8, 1.8);
    newGraphic.visible = false;
    newGraphic.zIndex = 300;
    add(newGraphic);

    descriptionBox = new FunkinSprite(0, 500);
    descriptionBox.makeSolidColor(850, 200, 0xFF000000);
    descriptionBox.camera = uiCamera;
    descriptionBox.alpha = 0.6;
    descriptionBox.screenCenter(0x01);
    descriptionBox.zIndex = 350;
    add(descriptionBox);

    currentCharacterIcon = new HealthIcon('dad', 0);
    currentCharacterIcon.camera = uiCamera;
    currentCharacterIcon.zIndex = 300;
    add(currentCharacterIcon);

    unlockSound = new FunkinSound();
    unlockSound.loadEmbedded(Paths.sound('funkerSelector/charUnlock'));
    unlockSound.volume = 1;

    // Apply the zIndex
    refresh();

    // Set the window title.
    WindowUtil.setWindowTitle('Friday Night Funkin\' - Funker Selector Menu');

    trace('[Funker Selector] UI has been set up.');
    conductorInUse.forceBPM(songBPM);
  }

  /**
   * Bopping the icons, because why not?
   */
  function bopDaThing():Void
  {
    if (currentCharacterIcon != null)
    {
      if (currentCharacterIcon.width > currentCharacterIcon.height)
      {
        currentCharacterIcon.setGraphicSize(Std.int(currentCharacterIcon.width + (150 * currentCharacterIcon.size.x * 0.2)), 0);
      }
      else
      {
        currentCharacterIcon.setGraphicSize(0, Std.int(currentCharacterIcon.height + (150 * currentCharacterIcon.size.y * 0.2)));
      }

      currentCharacterIcon.angle += 1;

      currentCharacterIcon.updateHitbox();
      currentCharacterIcon.updatePosition();
    }
  }

  /**
   * Flash the screen with a specific color.
   * @param color The color to use.
   * @param duration The duration of the flash.
   * @param alpha The alpha of the flash.
   */
  function flashScreen(color:FlxColor, duration:Float, ?alpha:Float = 1)
  {
    var duration:Float = duration;
    var alpha:Float = alpha;

    var white = new FunkinSprite(0, 0);
    white.makeSolidColor(FlxG.width, FlxG.height, color);
    white.alpha = 0;
    white.camera = uiCamera;
    this.add(white);

    FlxTween.tween(white, {alpha: alpha}, duration,
      {
        ease: FlxEase.quadOut,
        onComplete: function(twn:FlxTween) {
          FlxTween.tween(white, {alpha: alpha}, duration,
            {
              ease: FlxEase.quadOut,
              onComplete: function(twn:FlxTween) {
                this.remove(white);
              }
            });
        }
      });
  }

  /**
   * Reponsible for handling inputs in the menu.
   */
  function handleKeyShit():Void
  {
    if (controls.BACK)
    {
      if (hotkeyBox.visible)
      {
        hotkeyBox.visible = false;
        hotkeyBoxText.visible = false;
      }
      else
      {
        FunkinSound.playOnce(Paths.sound('cancelMenu'));

        // Scripted characters overwrite the suffixes when
        // they're shown. So we want to manually reset them!
        PauseSubState.musicSuffix = '';
        GameOverSubState.musicSuffix = '';
        GameOverSubState.blueBallSuffix = '';

        WindowUtil.setWindowTitle('Friday Night Funkin\'');
        ModuleHandler.callEvent(new ScriptEvent(FS_EXITED_SUBSTATE));

        close();
      }
    }

    if (!hotkeyBox.visible)
    {
      var leftPressed:Bool = controls.UI_LEFT;
      var rightPressed:Bool = controls.UI_RIGHT;
      var anyPressed:Bool = leftPressed || rightPressed;

      if (anyPressed)
      {
        if ((spamming && spamTimer >= 0.07) || (!spamming && spamTimer <= 0))
        {
          spamTimer = 0;

          if (leftPressed)
          {
            changeCharacter(-1);
          }
          else if (rightPressed)
          {
            changeCharacter(1);
          }
        }
        else if (!spamming && spamTimer >= 0.9)
        {
          spamming = true;
        }

        spamTimer += elapsed;
      }
      else
      {
        spamming = false;
        spamTimer = 0;
      }

      leftDifficultyArrow.animation.play(leftPressed ? 'press' : 'idle');
      rightDifficultyArrow.animation.play(rightPressed ? 'press' : 'idle');

      if (controls.FREEPLAY_LEFT || controls.FREEPLAY_RIGHT)
      {
        changePage(controls.FREEPLAY_LEFT ? -1 : 1);
      }

      // Mouse scrolling:
      // Up = Left
      // Down = Right
      if (FlxG.mouse.wheel < 0)
      {
        changeCharacter(1);
      }
      else if (FlxG.mouse.wheel > 0)
      {
        changeCharacter(-1);
      }

      if (controls.FREEPLAY_JUMP_TO_TOP)
      {
        changeCharacter(-currentCharacterIndex);
      }

      if (controls.FREEPLAY_JUMP_TO_BOTTOM)
      {
        if (!saveData.preferences.potatoMode)
        {
          changeCharacter(characterWheel.length - currentCharacterIndex);
        }
        else
        {
          changeCharacter(filteredKeys.indexOf(filteredKeys.length) - currentCharacterIndex);
        }
      }

      if (controls.FREEPLAY_CHAR_SELECT)
      {
        if (saveData.preferences.preferredSFX == "charSelect")
        {
          FunkinSound.playOnce(Paths.sound('CS_select'), 0.2);
        }
        else
        {
          FunkinSound.playOnce(Paths.sound('scrollMenu'), 0.4);
        }
        jumpToCurSelected();
      }

      if (controls.FREEPLAY_FAVORITE)
      {
        var shouldPlaySound:Bool = false;
        var saveObject:Dynamic = ModuleHandler.getModule('FS_SaveDataHandler').scriptCall('getSaveData');

        if (saveObject.characterIDs.bf != 'default')
        {
          saveObject.characterIDs.bf = 'default';
          shouldPlaySound = true;
        }
        if (saveObject.characterIDs.dad != 'default')
        {
          saveObject.characterIDs.dad = 'default';
          shouldPlaySound = true;
        }
        if (saveObject.characterIDs.gf != 'default')
        {
          saveObject.characterIDs.gf = 'default';
          shouldPlaySound = true;
        }
        if (shouldPlaySound)
        {
          FunkinSound.playOnce(Paths.sound('ranks/great'), 0.4);
          selected.visible = selectedTextVisibility();
          FS_SaveDataHandler.scriptCall('writeSaveData', [saveObject]);

          // Jump to default.
          jumpToCurSelected();
        }
      }

      if (controls.RESET)
      {
        hotkeyBox.visible = true;
        hotkeyBoxText.visible = true;
      }

      if (controls.DEBUG_MENU)
      {
        showVariations(currentCharacterID);
      }

      if (controls.ACCEPT)
      {
        var saveObject:Dynamic = ModuleHandler.getModule('FS_SaveDataHandler').scriptCall('getSaveData');
        var characterIDs:Dynamic = saveObject.characterIDs;
        var characterSlot:String = characterSlots[currentPageIndex][0];
        var savedCharacterID:String = ReflectUtil.getAnonymousField(characterIDs, characterSlot);
        var shouldConfirm:Bool = false;

        if (currentCharacterID != savedCharacterID)
        {
          if (!lockedCharMap.exists(currentCharacterID))
          {
            var characterIDs:Dynamic = saveObject.characterIDs;
            var characterSlot:String = characterSlots[currentPageIndex][0];

            if (currentCharacterID != savedCharacterID)
            {
              ReflectUtil.setAnonymousField(characterIDs, characterSlot, currentCharacterID);
              shouldConfirm = true;
            }
          }
        }
        if (shouldConfirm)
        {
          confirmThing();
          selected.visible = selectedTextVisibility();
          newGraphic.visible = false;
          FS_SaveDataHandler.scriptCall('writeSaveData', [saveObject]);
        }
        else
        {
          if (saveData.preferences.preferredSFX == "charSelect")
          {
            FunkinSound.playOnce(Paths.sound('CS_locked'), 0.4);
          }
          else
          {
            FunkinSound.playOnce(Paths.sound('cancelMenu'));
          }
          flashScreen(0xFFFF0000, 0.03, 0.1);
          if (!saveData.preferences.potatoMode)
          {
            for (index in 0...characterWheel.members.length)
            {
              var item = characterWheel.members[index];
              if (index == currentCharacterIndex - 1 && item is FunkinSprite) item.animation.play('denied', true);
            }
          }
          else
          {
            if (lockedChill != null) lockedChill.playAnimation("clicked", true);
          }
        }
      }
    }
  }

  /**
   * Jumps to the currently selected character.
   */
  function jumpToCurSelected():Void
  {
    var saveObject:Dynamic = ModuleHandler.getModule('FS_SaveDataHandler').scriptCall('getSaveData');
    var characterIDs:Dynamic = saveObject.characterIDs;
    var characterSlot:String = characterSlots[currentPageIndex][0];
    var savedCharacterID:String = ReflectUtil.getAnonymousField(characterIDs, characterSlot);

    // In the event that the saved character ID no longer exists, we fallback to default.
    if (!characterMap.exists(savedCharacterID) && savedCharacterID != 'default')
    {
      trace('[Funker Selector] Saved character ID doesn\'t exist! Resetting to default.');
      ReflectUtil.setAnonymousField(characterIDs, characterSlot, 'default');

      // Save everything
      FS_SaveDataHandler.scriptCall('writeSaveData', [saveObject]);
    }
    currentCharacterIndex = filteredKeys.indexOf(savedCharacterID);
    currentCharacterID = savedCharacterID;
    changeCharacter();
    updateCharInfo();
  }

  /**
   * Called when the `ACCEPT` keybind is pressed.
   * Plays some effects.
   */
  function confirmThing():Void
  {
    if (saveData.preferences.preferredSFX == "charSelect")
    {
      FunkinSound.playOnce(Paths.sound('CS_confirm'), 0.4);
    }
    else
    {
      FunkinSound.playOnce(Paths.sound('confirmMenu'));
    }

    if (!saveData.preferences.potatoMode && currentCharacterID != "default")
    {
      var fs_characterData:FS_characterData = FS_CharacterDataHandler.scriptCall('getCharacterData', [currentCharacterID]);
      var animation:String = fs_characterData.characterMenu.selectedAnim;
      var item:Dynamic = characterWheel.members[currentCharacterIndex - 1];

      if (item != null)
      {
        if (item is Bopper)
        {
          item.playAnimation(animation, true, true);
          item.animation.onFinish.addOnce(function() {
            item.dance();
          });
        }
      }
    }

    if (currentCharacterIcon.hasAnimation('winning'))
    {
      // Play the winning animation if it's available.
      currentCharacterIcon.playAnimation('winning');

      // I wanted this really cool effect where the icons in the icon grid would also
      // play the winning animation!
      // But let's not play that if "Simplify UI" is turned on.
      if (!saveData.preferences.potatoMode && iconGrid != null)
      {
        for (i in 0...iconGrid.length)
        {
          var icon = iconGrid[i];
          new FlxTimer().start(0.01 * i, function() {
            icon.playAnimation('winning');
          });
        }
        new FlxTimer().start(0.3, function() {
          for (i in 0...iconGrid.length)
          {
            var icon = iconGrid[i];
            new FlxTimer().start(0.01 * i, function() {
              icon.playAnimation('idle');
            });
          }
        });
      }
    }

    flashScreen(0xFFFFFFFF, 0.03, 0.1);
  }

  /**
   * Displays the available character variations.
   * @param characterID The character ID we're using.
   */
  function showVariations(characterID:String):Void
  {
    var fs_characterData = FS_CharacterDataHandler.scriptCall('getCharacterData', [characterID]);
    var variationCount:Int = FS_CharacterDataHandler.scriptCall('getCharacterData', [characterID, 1]);
    var alertBody:String = "";

    if (variationCount <= 0) return;
    if (lockedCharMap.exists(characterID)) return;
    if (characterID == 'default') return;

    for (variation in fs_characterData.characterVariations)
    {
      var characterName:String = "";
      var songNames:Array<String> = [];

      for (songID in variation.songID)
      {
        var songData:SongMetadata = SongRegistry.instance.parseEntryMetadata(songID, variation.songVariation);
        var characterData:CharacterData = CharacterDataParser.fetchCharacterData(variation.characterID);
        characterName = characterData?.name ?? "NONEXISTENT CHARACTER ID (" + variation.characterID + ")";
        songNames.push(songData?.songName ?? "NONEXISTENT SONG ID (" + songID + ")");
      }

      alertBody += "Name: " + characterName + "\n";
      alertBody += "Songs: " + songNames.join(", ");

      if (fs_characterData.characterVariations.indexOf(variation) < fs_characterData.characterVariations.length - 1)
      {
        alertBody += "\n\n";
      }
    }

    PolymodErrorHandler.showAlert("Available character variations", alertBody);
  }

  /**
   * Does a really fucking cool unlock animation.
   */
  function doUnlockAnimation(?skip:Bool):Void
  {
    if (!saveData.preferences.potatoMode)
    {
      for (index in 0...characterWheel.members.length)
      {
        var item = characterWheel.members[index];
        if (index == currentCharacterIndex - 1 && item is FunkinSprite)
        {
          lockedChill = item;
          break;
        }
      }
    }

    if (lockedChill is FunkinSprite)
    {
      lockedChill.animation.callback = function(name, frame) {
        if (name == 'death' && frame == 36)
        {
          finishUnlockAnim(false);
        }
      }
    }
    else
    {
      lockedChill.onAnimationFrame.add(function(name, frame) {
        if (name == 'unlock' && frame == 36)
        {
          finishUnlockAnim(true);
        }
      });
    }

    if (skip)
    {
      skipUnlockAnim(lockedChill);
      return;
    }

    if (FlxG.sound.music != null) FlxG.sound.music.fadeOut();

    if (!saveData.preferences.potatoMode)
    {
      lockedChill.offset.set();
      lockedChill.animation.play('idle', true);
    }
    else
    {
      lockedChill.playAnimation('idle', true);
    }

    FlxTween.tween(uiCamera, {alpha: 0}, 1,
      {
        ease: FlxEase.quartOut,
        onComplete: function(twn:FlxTween) {
          unlockSound.play(true);
          new FlxTimer().start(1.45, function() {
            if (!saveData.preferences.potatoMode)
            {
              lockedChill.offset.set(170, 220);
              lockedChill.animation.play('death');
            }
            else
            {
              lockedChill.playAnimation('unlock');
            }
          });
        }
      });
  }

  /**
   * Replaces and updates the Character.
   */
  function finishUnlockAnim(simplifyUI:Bool):Void
  {
    flashScreen(0xFFFFFFFF, 0.05, 1);
    new FlxTimer().start(0.025, function() {
      updateCharInfo();
      if (selected.visible) selected.visible = false;
      newGraphic.visible = true;
      uiCamera.shake(0.01, 0.2);
      FlxG.state.subState.funnyCam.shake(0.01, 0.2);
    });

    if (!simplifyUI)
    {
      fs_characterData = FS_CharacterDataHandler.scriptCall('getCharacterData', [currentCharacterID]);
      characterWheel.replace(lockedChill, buildCharacterSprite(fs_characterData));
    }

    busy = false;
    uiCamera.alpha = 1;

    if (FlxG.sound.music != null) FlxG.sound.music.fadeIn();
  }

  /**
   * Skips the unlock animation.
   */
  function skipUnlockAnim(lockedChill:Dynamic):Void
  {
    if (lockedChill is FunkinSprite)
    {
      lockedChill.offset.set(170, 220);
      lockedChill.animation.play('death');
      lockedChill.animation.pause();
      lockedChill.animation.curAnim.curFrame = 36;
      lockedChill.animation.resume();

      if (saveData.preferences.preferredSFX == "charSelect")
      {
        FunkinSound.playOnce(Paths.sound('CS_confirm'), 0.4);
      }
      else
      {
        FunkinSound.playOnce(Paths.sound('confirmMenu'));
      }
    }
    else
    {
      lockedChill.playAnimation('unlock');
      lockedChill.anim.pause();
      lockedChill.anim.curFrame = 34;
      lockedChill.anim.resume();

      if (saveData.preferences.preferredSFX == "charSelect")
      {
        FunkinSound.playOnce(Paths.sound('CS_confirm'), 0.4);
      }
      else
      {
        FunkinSound.playOnce(Paths.sound('confirmMenu'));
      }
    }
  }

  /**
   * Adjusts the description size relative to the description text box.
   * @param characterDescription The `characterDescription` FlxText object.
   */
  function adjustFontSize(characterDescription:FlxText):Void
  {
    if (characterDescription == null) return;
    var currentFontSize = characterDescription.size;
    var maxHeight = descriptionBox.height - 10;
    if (characterDescription.fieldHeight > maxHeight)
    {
      currentFontSize--;

      characterDescription.size = currentFontSize;
      characterDescription.letterSpacing -= 0.16 * (currentFontSize / 10);

      if (currentFontSize <= 8) return;
    }
  }

  /**
   * Update character information.
   */
  function updateCharInfo():Void
  {
    var variationCount:Int = 0;

    selectText.text = topText[currentPageIndex];
    selectText.color = topTextColor[currentPageIndex];
    selectText.screenCenter(0x01);
    selected.visible = selectedTextVisibility();

    newGraphic.visible = false;

    if (currentCharacterID != 'default')
    {
      fs_characterData = FS_CharacterDataHandler.scriptCall('getCharacterData', [currentCharacterID]);
      characterData = CharacterDataParser.fetchCharacterData(currentCharacterID);
      variationCount = FS_CharacterDataHandler.scriptCall('getCharacterData', [currentCharacterID, 1]);
    }

    switch (currentCharacterID)
    {
      case 'default':
        currentCharacterIcon.configure('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');
        characterName.text = "DEFAULT";
        descriptionText = "This is the Default character defined by the song.";
      default:
        if (lockedCharMap.exists(currentCharacterID))
        {
          characterName.text = "LOCKED";

          var unlockHint = "\n\nUnlock Condition: " + fs_characterData.description.unlockCondition;

          descriptionText = "This character is locked! I wonder who it could be..." + unlockHint;
        }
        else
        {
          characterName.text = characterData?.name;
          currentCharacterIcon.configure(characterData?.healthIcon);
          currentCharacterIcon.size.set(1, 1);
          currentCharacterIcon.setPosition(270, 380);

          descriptionText = fs_characterData.description.text;
        }
    }

    // Reset the description size and letter spacing.
    characterDescription.size = 35;
    characterDescription.letterSpacing = 0;

    characterDescription.resetText(descriptionText);
    characterDescription.start(0.01);

    // Making it not look so awkward when "Simplify UI" is turned on.
    if (saveData.preferences.potatoMode || currentCharacterID == 'default')
    {
      currentCharacterIcon.setPosition(500, 230);
      currentCharacterIcon.size.set(1.7, 1.7);
    }

    if (!saveData.preferences.potatoMode)
    {
      for (icon in iconGrid)
      {
        if (currentCharacterID == 'default' || lockedCharMap.exists(currentCharacterID))
        {
          icon.configure('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');
        }
        else if (icon.characterId != characterData?.healthIcon.id)
        {
          icon.configure(characterData?.healthIcon);
        }
      }
    }

    variationText.screenCenter(0x01);
    variationText.text = "This character has " + variationCount + " available " + (variationCount == 1 ? "variation" : "variations");

    if (variationCount > 0 && !lockedCharMap.exists(currentCharacterID))
    {
      trace("[Funker Selector] Variations found for character ID " + currentCharacterID);
      variationText.visible = true;
    }
    else
    {
      variationText.visible = false;
    }

    if (lockedCharMap.exists(currentCharacterID))
    {
      if (currentCharacterIcon != null) currentCharacterIcon.visible = false;
      if (saveData.preferences.potatoMode) lockedChill.visible = true;
    }
    else
    {
      if (currentCharacterIcon != null) currentCharacterIcon.visible = true;
      if (saveData.preferences.potatoMode) lockedChill.visible = false;
    }

    characterName.screenCenter(0x01);

    selected.y = characterDescription.y - 60;

    // Do the unlock animation if we haven't seen it yet.
    if (lockedCharMap.exists(currentCharacterID)
      && FS_CharacterDataHandler.scriptCall('isCharacterUnlocked', [currentCharacterID, fs_characterData.unlockMethod]))
    {
      var saveObject:Dynamic = ModuleHandler.getModule('FS_SaveDataHandler').scriptCall('getSaveData');

      if (!saveObject.seenUnlocks.contains(currentCharacterID))
      {
        lockedCharMap.remove(currentCharacterID);
        saveObject.seenUnlocks.push(currentCharacterID);

        FS_SaveDataHandler.scriptCall('writeSaveData', [saveObject]);
        FS_CharacterDataHandler.scriptSet('lockedCharMap', lockedCharMap);

        busy = true;
        doUnlockAnimation(FlxG.keys.pressed.SHIFT);
      }
    }
  }

  /**
   * HELPER FUNCTIONS
   * These are functions that are simply nice to have. They make the code cleaner.
   */
  /**
   * Something.
   * @return Whether it's the selected character.
   */
  function selectedTextVisibility():Bool
  {
    var characterIDs:Dynamic = FS_SaveDataHandler.scriptCall('getSaveData').characterIDs;
    var characterSlot:String = characterSlots[currentPageIndex][0];

    return currentCharacterID == ReflectUtil.getAnonymousField(characterIDs, characterSlot);
  }

  /**
   * Helper function for configuring a FlxText
   * @param object The FlxText object
   * @param text The text itself
   * @param offsets The offsets as an array
   * @param size The size of the text
   * @param font The font
   * @return A FlxText object
   */
  function configureText(object:FlxText, ?text:String = "", ?offsets:Array<Int>, ?size:Int = 38, ?font:String = null, ?typeText:Bool = false):FlxText
  {
    if (text == null) text = "";
    if (offsets == null) offsets = [0, 0];
    if (size == null) size = 35;
    if (object == null)
    {
      if (typeText)
      {
        object = new FlxTypeText(0, 0, 0, "PLACEHOLDER");
      }
      else
      {
        object = new FlxText(0, 0, 0, "PLACEHOLDER");
      }
    }

    object.text = text;
    object.x += offsets[0];
    object.y += offsets[1];
    if (font != null) object.setFormat(font, size, null, 'center');

    return object;
  }
}
