import Array;
import flixel.FlxG;
import flixel.graphics.FlxGraphic;
import flixel.util.FlxSave;
import funkin.audio.FunkinSound;
import funkin.audio.VoicesGroup;
import funkin.data.freeplay.player.PlayerRegistry;
import funkin.data.song.SongRegistry;
import funkin.graphics.FunkinSprite;
import funkin.modding.PolymodErrorHandler;
import funkin.modding.base.ScriptedMusicBeatSubState;
import funkin.modding.module.Module;
import funkin.play.GameOverSubState;
import funkin.play.PauseSubState;
import funkin.play.PlayState;
import funkin.play.PlayStatePlaylist;
import funkin.play.ResultState;
import funkin.play.character.CharacterDataParser;
import funkin.play.character.CharacterType;
import funkin.save.Save;
import funkin.ui.AtlasText;
import funkin.ui.freeplay.FreeplayState;
import funkin.ui.options.OptionsState;
import funkin.util.Constants;
import funkin.util.MemoryUtil;
import funkin.util.assets.DataAssets;
import haxe.Json;
import haxe.Exception;
import haxe.ds.StringMap;
import lime.app.Application;
import openfl.display.BitmapData;
import openfl.display3D.textures.RectangleTexture;
import openfl.display3D.textures.TextureBase;
import Std;
import String;

/**
 * Module that handles the Character Select button in
 * Freeplay, along with character replacement.
 */
class CharacterHandler extends Module {
	/**
	 * The character IDs.
	 * This is retrieved from the save data.
	 */
	public var characterIDs:Dynamic;

	/**
	 * The preferences for Funker Selector specifically.
	 * This is retrieved from the save data.
	 */
	public var funkerSettings:Dynamic;

	/**
	 * The current voice list, used for vocal replacement.
	 */
	var voiceList:Array<String>;

	/**
	 * The current supported game version.
	 * NOTE: Only change this if there's breaking changes that
	 * make it not function on older versions!!
	 * 
	 * TODO: Add a proper version rule. (Like ranges and stuff.)
	 */
	var supportedVersion:String = "0.5.1";

	/**
	 * currentCachedTextures gets cleared everytime we load into a song.
	 * It'd be annoying to have to re-cache everything everytime we exit, so we
	 * keep track of JSON characters in a separate map instead.
	 */
	var cachedJSONSparrows:StringMap<String, FlxGraphic> = new StringMap();

	var ogCharID:String = null;

	var charText:AtlasText;
	var charSelectIcon:FunkinSprite;

	function new() {
		super("CharacterHandler");

		// The FIRST thing we check is the game version.
		// We use `lime.app.Application` instead of `Constants.VERSION` because the latter
		// has added suffixes depending on if the game is a debug build or not.
		if (isVersionBelow(Application.current.meta.get('version'), supportedVersion)) {
			PolymodErrorHandler.showAlert("Funker Selector Error",
				"Funker Selector is not supported on Friday Night Funkin' v"
				+ Application.current.meta.get('version')
				+ ".\n\nPlease update to v"
				+ supportedVersion
				+ "!");
			this.active = false;
			return;
		}

		// Initialize the save data.
		initializeSave();
	}

	/**
	 * Retrieves Character IDs and Preferences from the save data.
	 */
	function initializeSave():Void {
		var save:FlxSave = new FlxSave();

		var defaultCharacterIDs:Dynamic = {
			bf: 'default',
			gf: 'default',
			dad: 'default'
		};

		var defaultSettings:Dynamic = {
			potatoMode: false,
			preloadSprites: true
		};

		if (Save.instance.modOptions.get("FunkerSelector") == null) {
			// Backwards compatability with the old save system from v1.1 and under.
			if (save.bind("characterselect", "kagaminerinlen")) {
				if (save.data.characterselect != null) {
					defaultCharacterIDs.bf = save.data.characterselect;
					save.data.characterselect = null;
					save.close();
				}
			}

			Save.instance.modOptions.set("FunkerSelector", defaultCharacterIDs);
			Save.instance.flush();
			characterIDs = defaultCharacterIDs;

			trace('[Funker Selector] Successfully created save data:\n\nBoyfriend: '
				+ characterIDs.bf
				+ '\nGirlfriend: '
				+ characterIDs.gf
				+ '\nOpponent: '
				+ characterIDs.dad);
		} else {
			characterIDs = Save.instance.modOptions.get("FunkerSelector");
			trace('[Funker Selector] Successfully retrieved save data:\n\nBoyfriend: '
				+ characterIDs.bf
				+ '\nGirlfriend: '
				+ characterIDs.gf
				+ '\nOpponent: '
				+ characterIDs.dad);
		}

		if (Save.instance.modOptions.get("FunkerSelectorSettings") == null) {
			Save.instance.modOptions.set("FunkerSelectorSettings", defaultSettings);
			Save.instance.flush();
			funkerSettings = defaultSettings;

			trace('[Funker Selector] Successfully created save data:\n\nSimplify UI: '
				+ funkerSettings.potatoMode
				+ '\nPreload Sprites: '
				+ funkerSettings.preloadSprites);
		} else {
			funkerSettings = Save.instance.modOptions.get("FunkerSelectorSettings");
			trace('[Funker Selector] Successfully retrieved save data:\n\nSimplify UI: '
				+ funkerSettings.potatoMode
				+ '\nPreload Sprites: '
				+ funkerSettings.preloadSprites);
		}
	}

	function onCreate(event) {
		super.onCreate(event);
		// Cache the sprites for JSON characters.
		// This is only done once.
		if (!funkerSettings.potatoMode) {
			if (funkerSettings.preloadSprites)
				cacheJSONSparrows();
		}
	}

	function onUpdate(event) {
		super.onUpdate(event);
		if (FlxG.state.subState is FreeplayState) {
			// Open the CharacterMenu substate.
			// We need to make a new one everytime since it gets destroyed when it's closed.
			if (FlxG.keys.justPressed.G && charText.visible) {
				var charSelect:FlxSubState = ScriptedMusicBeatSubState.init("CharacterSelectSubState");
				charSelect.camera = FlxG.state.subState.funnyCam;
				FlxG.state.subState.persistentUpdate = false;
				FlxG.state.subState.openSubState(charSelect);
			}
		}
	}

	/**
	 * Stuff for Results and Freeplay.
	 */
	function onSubStateOpenEnd(event) {
		super.onSubStateOpenEnd(event);
		var state = event.targetState;
		// Set up the Character Select button.
		if (state is FreeplayState) {
			charSelectIcon = FunkinSprite.createSparrow(10, 120, 'freeplay/char_select');
			charSelectIcon.animation.addByPrefix('intro', 'icon enter', 24, false);
			charSelectIcon.animation.addByPrefix('idle', 'idle', 24, true);
			charSelectIcon.zIndex = 1000;
			charSelectIcon.scale.set(0.7, 0.7);
			charSelectIcon.camera = state.funnyCam;
			charSelectIcon.visible = false;

			charText = new AtlasText(170, 270, 'G', 'bold');
			charText.visible = false;
			charText.zIndex = 1001;
			charText.camera = state.funnyCam;

			state.add(charSelectIcon);
			state.add(charText);

			state.dj.onIntroDone.add(function() {
				charSelectIcon.visible = true;
				charSelectIcon.animation.play('intro');
				charSelectIcon.animation.finishCallback = function(_) {
					charSelectIcon.animation.play('idle');
					charText.visible = true;
					if (charSelectIcon.animation.curAnim.name == 'idle')
						charSelectIcon.offset.set(-15, 14);
					else
						charSelectIcon.offset.set();
				};
			});
		}

		// Results screen bullshit.
		if (state is ResultState) {
			// More playable character shit
			// The results anim will still play, it's just Freeplay won't bug out when we do this.
			// If the original player is part of a Playable Character, we don't do this.
			if (PlayState.instance.currentStage.getBoyfriend()?.characterId == characterIDs.bf) {
				PlayState.instance.currentChart.characters.player = ogCharID;
				state.playerCharacterId = null;
				if (PlayerRegistry.instance.isCharacterOwned(ogCharID))
					state.playerCharacterId = PlayerRegistry.instance.getCharacterOwnerId(ogCharID);
			}
		}
	}

	/**
	 * Resetting Game Over and Pause Menu suffixes.
	 * We put this in `onStateChangeBegin();` instead of `onStateChangeEnd();`, otherwise,
	 * scripted characters will have their suffixes overridden!
	 */
	override function onStateChangeBegin(event) {
		super.onStateChangeBegin(event);
		if (event.targetState is PlayState) {
			PauseSubState.musicSuffix = '';
			GameOverSubState.musicSuffix = '';
			GameOverSubState.blueBallSuffix = '';

			// Reload the song entries since `PlayState.instance.currentChart.characters.player`
			// doesn't reset properly when we change it.
			// TODO: Find the root cause and fix this in Funkin's source code.
			SongRegistry.instance.loadEntries();
		}
	}

	override function onStateChangeEnd(event) {
		super.onStateChangeEnd(event);

		// Options Menu stuff
		if (event.targetState is OptionsState) {
			var prefs = event.targetState.pages.get("preferences");
			if (prefs != null) {
				prefs.add(prefs.items.createItem(120, 120 * prefs.items.length + 30, "-- FUNKER SELECTOR --", "bold", () -> {})).fireInstantly = true;

				prefs.createPrefItemCheckbox("Simplify UI", "Is the new Fancy UI too much for your device? No problem!", (value) -> {
					funkerSettings.potatoMode = value;
					Save.instance.modOptions.set("FunkerSelectorSettings", funkerSettings);
					Save.instance.flush();
				}, funkerSettings.potatoMode);

				prefs.createPrefItemCheckbox("Preload Sprites",
					"Wether to preload the character sprites or not. Will cause lag on the Character Selection Menu if off!", (value) -> {
						funkerSettings.preloadSprites = value;
						Save.instance.modOptions.set("FunkerSelectorSettings", funkerSettings);
						Save.instance.flush();
						if (value) {
							cacheJSONSparrows();
						} else {
							// Remove the JSON Characters from memory when the user disables the option.
							for (jsonChar in cachedJSONSparrows.keys()) {
								var char = cachedJSONSparrows.get(jsonChar);
								if (char == null)
									continue;
								FlxG.bitmap.remove(char);
								char.persist = false;
								char.destroyOnNoUse = true;
								char.destroy();
								cachedJSONSparrows.remove(jsonChar);
							}
							MemoryUtil.collect(true);
						}
					}, funkerSettings.preloadSprites);

				prefs.add(prefs.items.createItem(120, 120 * prefs.items.length, "-------------------", "bold", () -> {})).fireInstantly = true;
			}
		}
	}

	/**
	 * Parse a Funker Selector JSON file and return the data.
	 * @param characterID The character ID to use.
	 * @return The JSON data.
	 */
	function parseJSONData(characterID:String = 'default'):Void {
		if (Assets.exists(Paths.json('funkerSelector/' + characterID))) {
			var data = Json.parse(Assets.getText(Paths.json('funkerSelector/' + characterID)));
			return data;
		} else {
			return null;
		}
	}

	/**
	 * We preload the sprites for the JSON characters
	 * when the Module is created in order to reduce lag when
	 * they're shown in the Character Selection screen.
	 *
	 * If "Simplify UI" is enabled, the sprites are not
	 * cached as they won't show up in the menu.
	 */
	function cacheJSONSparrows():Void {
		var funkerJSONs = DataAssets.listDataFilesInPath('funkerSelector/');
		var data = null;
		for (funker in funkerJSONs) {
			// Exceptions continue the loop so there's no need for a continue; here.
			try {
				data = Json.parse(Assets.getText(Paths.json('funkerSelector/' + funker)));
			} catch (e:Dynamic) {
				trace(':(');
			}

			if (!charJSONCheck(data.characterID)) {
				trace('[ERROR] Failed to cache sprite! The Character ID (' + data.characterID + ') is invalid.');
				continue;
			}
			var charData = CharacterDataParser.parseCharacterData(data.characterID);
			if (data.characterID == null) {
				trace('[ERROR] Failed to cache sprite for ' + Assets.getPath(Paths.json('funkerSelector/' + funker))
					+ '! The "characterID" field does not exist.');
				continue;
			}

			switch (charData.renderType) {
				case 'multisparrow':
					for (anim in charData.animations) {
						if (anim.assetPath != null)
							cacheSprite(Paths.image(anim.assetPath));
					}
				case 'animateatlas':
					cacheSprite(Paths.image(charData.assetPath + '/spritemap1'));
				case 'sparrow':
					cacheSprite(Paths.image(charData.assetPath));
				default:
					cacheSprite(Paths.image(charData.assetPath));
			}
		}
	}

	/**
	 * This is taken from Psych Engine, with some modifications.
	 * This is a lot more Memory-efficient compared to using FunkinSprite's cacheSparrow function!
	 *
	 * @param path The file path.
	 */
	function cacheSprite(path:String) {
		if (cachedJSONSparrows.exists(path))
			return;
		var bitmap:BitmapData = Assets.getBitmapData(path);
		if (bitmap != null) {
			var texture:RectangleTexture = FlxG.stage.context3D.createRectangleTexture(bitmap.width, bitmap.height, "bgra", true);
			texture.uploadFromBitmapData(bitmap);
			bitmap.image.data = null;
			bitmap.dispose();
			bitmap.disposeImage();
			bitmap = BitmapData.fromTexture(texture);
			var graphic:FlxGraphic = FlxGraphic.fromBitmapData(bitmap, false, path);
			graphic.persist = true;
			cachedJSONSparrows.set(path, graphic);
			trace('[Funker Selector] Successfully cached graphic: ' + path);
		} else {
			trace('[ERROR] Failed to cache graphic: ' + path);
		}
	}

	/**
	 * Reset the voiceList, swap out the characters, and
	 * replace vocals if any are found.
	 */
	override function onCountdownStart(event) {
		super.onCountdownStart(event);
		if (PlayState.instance == null
			|| PlayState.instance.currentStage == null
			|| PlayStatePlaylist.isStoryMode
			|| PlayState.instance.isMinimalMode
			|| PlayState.instance.isChartingMode)
			return;

		// Setting voiceList to null in order to reset the voices,
		// since module variables persist between state changes.
		voiceList = [null, null];

		// Saving the original character ID.
		ogCharID = PlayState.instance.currentChart.characters.player;

		// Replace and swap out the characters.
		replaceChar(characterIDs.bf, 'bf');
		replaceChar(characterIDs.gf, 'gf');
		replaceChar(characterIDs.dad, 'dad');
		PlayState.instance.currentStage.refresh();

		// If at least ONE of them was changed (means a vocal file was found), replace the vocals.
		if (voiceList[0] != null || voiceList[1] != null) {
			PlayState.instance.vocals.stop();
			PlayState.instance.vocals = replaceVocals(voiceList);
		}
	}

	/**
	 * Changing `player` in `currentChart` to trick the Results Screen
	 * into loading the Results Screen animations for the currently
	 * selected character if they exist.
	 */
	function onSongEnd() {
		if (PlayerRegistry.instance.isCharacterOwned(characterIDs.bf)
			&& PlayState.instance.currentStage.getBoyfriend()?.characterId == characterIDs.bf) {
			PlayState.instance.currentChart.characters.player = characterIDs.bf;
		}
	}

	/**
	 * The actual logic for character replacement.
	 * For Boyfriend and Dad, it checks to see if a vocal
	 * file of the current song exists for the specified character,
	 * and replaces the original character's vocals with that.
	 *
	 * @param id The character ID to change into.
	 * @param type The character type we're replacing.
	 * 
	 */
	function replaceChar(id:String = 'bf', type:String = 'bf'):Void {
		var characterData = parseJSONData(id);
		var oldChar = null;
		var charType = null;

		if (id == 'default')
			return;
		switch (type) {
			case 'bf':
				oldChar = PlayState.instance.currentStage.getBoyfriend();
				charType = CharacterType.BF;
			case 'gf':
				oldChar = PlayState.instance.currentStage.getGirlfriend();
				charType = CharacterType.GF;
			case 'dad':
				oldChar = PlayState.instance.currentStage.getDad();
				charType = CharacterType.DAD;
			default:
				trace('How did you get here?');
				return;
		}

		// Return if the target character does not exist.
		if (oldChar == null)
			return;

		// TODO: Add visual indicator for variations.
		if (characterData != null && characterData.characterVariations != null) {
			for (variation in characterData.characterVariations) {
				if (variation.songID == null || variation.characterID == null) {
					continue;
				}

				var songMatch = false;
				var variationMatch = false;

				if (variation.songID is Array) {
					songMatch = (variation.songID.indexOf(PlayState.instance.currentSong.id) != -1);
				} else if (variation.songID is String) {
					songMatch = (variation.songID == PlayState.instance.currentSong.id);
				}

				if (variation.songVariation != null) {
					if (variation.songVariation is Array) {
						variationMatch = (variation.songVariation.indexOf(PlayState.instance.currentVariation) != -1);
					} else if (variation.songVariation is String) {
						variationMatch = (variation.songVariation == PlayState.instance.currentVariation);
					}
				} else {
					variationMatch = true; // Assume true if songVariation does not exist.
				}

				if (songMatch && variationMatch) {
					characterData = parseJSONData(variation.characterID) != null ? parseJSONData(variation.characterID) : characterData;

					if (charJSONCheck(variation.characterID)) {
						id = variation.characterID;
					} else {
						PolymodErrorHandler.showAlert('Funker Selector Error',
							'The character variation "' + variation.characterID + '" does not exist. The base character ID will be used instead.');
					}
					break;
				}
			}
		}

		var suffix:String = (PlayState.instance.currentVariation != null && PlayState.instance.currentVariation != 'default') ? '-'
			+ PlayState.instance.currentVariation : '';
		var voiceFile:String = Paths.voices(PlayState.instance.currentSong.id, '-' + id + suffix);

		// Don't bother replacing the character if both character IDs match.
		if (oldChar.characterId != id) {
			var charZIndex:Int = oldChar.zIndex;
			var character = CharacterDataParser.fetchCharacter(id);

			if (character != null) {
				oldChar.destroy();
				character.zIndex = charZIndex;
				PlayState.instance.currentStage.addCharacter(character, charType);
			} else {
				PolymodErrorHandler.showAlert('Funker Selector Error', 'Something went wrong replacing the ' + type + ' character. How the fuck???');
			}
		}

		if (characterData != null && type == 'bf') {
			PauseSubState.musicSuffix = (characterData.pauseMusicSuffix != null
				&& characterData.pauseMusicSuffix != '') ? characterData.pauseMusicSuffix : PauseSubState.musicSuffix;
			GameOverSubState.musicSuffix = (characterData.gameOverMusicSuffix != null
				&& characterData.gameOverMusicSuffix != '') ? characterData.gameOverMusicSuffix : GameOverSubState.musicSuffix;
			GameOverSubState.blueBallSuffix = (characterData.blueBallSuffix != null
				&& characterData.blueBallSuffix != '') ? characterData.blueBallSuffix : GameOverSubState.blueBallSuffix;
		}

		switch (type) {
			case 'bf':
				if (Assets.exists(voiceFile)) {
					voiceList[0] = voiceFile;
				}
			case 'dad':
				if (Assets.exists(voiceFile)) {
					voiceList[1] = voiceFile;
				}
		}
	}

	/**
	 * Copy-pasted from CharacterMenu.
	 */
	function charJSONCheck(string:String):Bool {
		if (Assets.exists(Paths.json('characters/' + string))) {
			for (json in DataAssets.listDataFilesInPath('characters/')) {
				if (json == string) {
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * Modified version of buildVocals(); to handle vocal replacement.
	 *
	 * @param voiceList The supplied array.
	 */
	function replaceVocals(voiceList:Array<String>):VoicesGroup {
		var currentChart = PlayState.instance.currentChart;
		var result:VoicesGroup = new VoicesGroup();
		var songVoices:Array<String> = currentChart.buildVoiceList();

		if (voiceList[0] != null) {
			result.addPlayerVoice(FunkinSound.load(voiceList[0]));
		} else {
			result.addPlayerVoice(FunkinSound.load(songVoices[0]));
		}

		if (voiceList[1] != null) {
			result.addOpponentVoice(FunkinSound.load(voiceList[1]));
		} else {
			result.addOpponentVoice(FunkinSound.load(songVoices[1]));
		}

		result.playerVoicesOffset = currentChart.offsets.getVocalOffset(currentChart.characters.player);
		result.opponentVoicesOffset = currentChart.offsets.getVocalOffset(currentChart.characters.opponent);

		return result;
	}

	/**
	 * Shitty helper function for comparing 2 version strings.
	 * It works so whatever.
	 * @param versionOne The version we're using.
	 * @param versionTwo The version we're comparing versionOne with.
	 * @return Bool
	 */
	function isVersionBelow(versionOne:String, versionTwo:String):Bool {
		var verOneSplit = versionOne.split(".");
		var verTwoSplit = versionTwo.split(".");

		for (i in 0...Math.max(verOneSplit.length, verTwoSplit.length)) {
			var verOnePart = i < verOneSplit.length ? Std.parseInt(verOneSplit[i]) : 0;
			var verTwoPart = i < verTwoSplit.length ? Std.parseInt(verTwoSplit[i]) : 0;

			// If Version 1 is below Version 2, we return true.
			if (verOnePart < verTwoPart)
				return true;

			// If Version 1 is ABOVE Version 2, we return false.
			if (verOnePart > verTwoPart)
				return false;
		}

		// Else, we return false anyway if they're the same!
		return false;
	}
}
