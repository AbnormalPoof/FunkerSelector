import flixel.FlxG;
import flixel.text.FlxText;
import flixel.tweens.FlxEase;
import flixel.tweens.FlxTween;
import funkin.data.freeplay.player.PlayerRegistry;
import funkin.modding.module.Module;
import funkin.modding.module.ModuleHandler;
import funkin.ui.freeplay.FreeplayDJ;
import funkin.ui.freeplay.FreeplayDJState;
import funkin.ui.freeplay.FreeplayState;
import haxe.Timer;

/**
 * Separate module for replacing the Freeplay DJ to prevent messy code in CharacterHandler.
 */
class DJReplace extends Module {
	public var characterIDs:Dynamic;

	public function new() {
		super('DJReplace');

		characterIDs = ModuleHandler.getModule("CharacterHandler").scriptCall('initializeCharIDs');
	}

	/**
	 * Swap out the Freeplay DJ.
	 * @param freeplay The Freeplay SubState we're using. 
	 */
	function transitionToNewDJ(freeplay:FreeplayState, ?inIntro:Bool = false):Void {
		var freeplayDJ = freeplay.dj;
		var playableCharData = freeplayDJ.playableCharData;

		if (!inIntro) {
			freeplay.busy = true;
			freeplayDJ.onIntroDone.removeAll();
			freeplayDJ.onAnimationComplete.add(replaceDJNoIntro);
			if (freeplayDJ.hasAnimation(playableCharData.getAnimationPrefix('charSelect'))) {
				freeplayDJ.currentState = FreeplayDJState.CharSelect;
				var animPrefix = playableCharData.getAnimationPrefix('charSelect');
				freeplayDJ.playFlashAnimation(animPrefix, true, false, false);
			}
		} else {
			replaceDJIntro();
		}
	}

	function replaceDJNoIntro():Void {
		var freeplayDJ = FlxG.state.subState.dj;
		var playableCharId = PlayerRegistry.instance.getCharacterOwnerId(characterIDs.bf);
		var playableChar = PlayerRegistry.instance.fetchEntry(playableCharId);
		var playableCharData = playableChar.getFreeplayDJData();

		var startTime = Timer.stamp();

		if (freeplayDJ.anim.curSymbol.name == freeplayDJ.playableCharData.getAnimationPrefix('charSelect')) {
			trace("[Funker Selector] Loading texture atlas: " + playableCharData.getAtlasPath());
			freeplayDJ.loadAtlas(playableCharData.getAtlasPath());
			freeplayDJ.characterId = playableCharId;
			freeplayDJ.playableCharData = playableCharData;

			freeplayDJ.currentState = FreeplayDJState.Intro;
			var animPrefix = playableCharData.getAnimationPrefix('intro');
			// TODO: Make the frame a variable.
			freeplayDJ.playFlashAnimation(animPrefix, true, false, false, 3);

			if (FlxG.state.subState.backingCard.funnyScroll != null)
				reapplyBackingText(FlxG.state.subState, playableChar.getFreeplayDJText(1), playableChar.getFreeplayDJText(2),
					playableChar.getFreeplayDJText(3));
			FlxG.state.subState.busy = false;

			freeplayDJ.onAnimationComplete.remove(replaceDJNoIntro);

			var endTime = Timer.stamp();
			var elapsedTime = Math.round((endTime - startTime) * 100) / 100;
			trace("[Funker Selector] replaceDJNoIntro took " + elapsedTime + " seconds to complete.");
		}
	}

	function replaceDJIntro():Void {
		var startTime = Timer.stamp();

		var freeplayDJ = FlxG.state.subState.dj;
		var playableCharId = PlayerRegistry.instance.getCharacterOwnerId(characterIDs.bf);
		var playableChar = PlayerRegistry.instance.fetchEntry(playableCharId);
		var playableCharData = playableChar.getFreeplayDJData();

		trace("[Funker Selector] Loading texture atlas: " + playableCharData.getAtlasPath());
		freeplayDJ.loadAtlas(playableCharData.getAtlasPath());
		freeplayDJ.characterId = playableCharId;
		freeplayDJ.playableCharData = playableCharData;

		if (FlxG.state.subState.backingCard.funnyScroll != null)
			reapplyBackingText(FlxG.state.subState, playableChar.getFreeplayDJText(1), playableChar.getFreeplayDJText(2), playableChar.getFreeplayDJText(3));

		freeplayDJ.anim.onComplete.remove(replaceDJIntro);

		var endTime = Timer.stamp();
		var elapsedTime = Math.round((endTime - startTime) * 100) / 100;
		trace("[Funker Selector] replaceDJIntro took " + elapsedTime + " seconds to complete.");
	}

	/**
	 * Replaces the backing text.
	 * @param freeplay The Freeplay SubState we're using.
	 * @param text1 The 1st string.
	 * @param text2 The 2nd string.
	 * @param text3 The 3rd string.
	 */
	function reapplyBackingText(freeplay:FreeplayState, text1:String, text2:String, text3:String) {
		trace("[Funker Selector] Applying backing text...");
		trace(text1);
		trace(text2);
		trace(text3);

		var funnyScrollArray:Array<Dynamic> = [
			freeplay.backingCard.funnyScroll,
			freeplay.backingCard.funnyScroll2,
			freeplay.backingCard.funnyScroll3
		];
		var moreWaysArray:Array<Dynamic> = [freeplay.backingCard.moreWays, freeplay.backingCard.moreWays2];
		for (scrollText in funnyScrollArray) {
			setupTextGroup(scrollText, 60, FlxG.width / 2, text1, -3.8, false);
		}

		for (scrollText in moreWaysArray) {
			setupTextGroup(scrollText, 43, FlxG.width, text2, 6.8, true);
		}

		setupTextGroup(freeplay.backingCard.txtNuts, 43, FlxG.width / 2, text3, 3.5, true);

		freeplay.backingCard.funnyScroll.funnyColor = 0xFFFF9963;
		freeplay.backingCard.funnyScroll2.funnyColor = 0xFFFF9963;
		freeplay.backingCard.funnyScroll3.funnyColor = 0xFFFEA400;
		freeplay.backingCard.moreWays.funnyColor = 0xFFFFF383;
		freeplay.backingCard.moreWays2.funnyColor = 0xFFFFF383;
	}

	/**
	 * Sets up `grpTexts` for a `BGScrollingText` object
	 * @param textObject The object we are using
	 * @param size The text size
	 * @param widthShit The width or something IDK
	 * @param text The text itself
	 * @param speed The speed of the text scrolling
	 * @param bold Wether or not the text is bold
	 */
	function setupTextGroup(textObject:Dynamic, size:Int = 10, widthShit:Int = 1, text:String = "FUCK", speed:Float = 1.0, bold:Bool = false):Void {
		textObject.grpTexts.clear();
		var testText:FlxText = new FlxText(0, 0, 0, text, size);
		testText.font = "5by7";
		testText.bold = bold;
		testText.updateHitbox();
		textObject.grpTexts.add(testText);

		var needed:Int = Math.ceil(widthShit / testText.frameWidth) + 1;

		for (i in 0...needed) {
			var lmfao:Int = i + 1;

			var coolText:FlxText = new FlxText((lmfao * testText.frameWidth) + (lmfao * 20), 0, 0, text, size);

			coolText.font = "5by7";
			coolText.bold = bold;
			coolText.updateHitbox();
			textObject.grpTexts.add(coolText);
		}

		textObject.speed = speed;
	}
}
