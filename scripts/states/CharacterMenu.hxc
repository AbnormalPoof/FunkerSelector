import flixel.FlxG;
import flixel.text.FlxText;
import flixel.tweens.FlxEase;
import flixel.tweens.FlxTween;
import flixel.util.FlxTimer;
import funkin.audio.FunkinSound;
import funkin.data.freeplay.player.PlayerRegistry;
import funkin.graphics.FunkinCamera;
import funkin.graphics.FunkinSprite;
import funkin.modding.PolymodErrorHandler;
import funkin.modding.module.ModuleHandler;
import funkin.play.GameOverSubState;
import funkin.play.PauseSubState;
import funkin.play.character.BaseCharacter;
import funkin.play.character.CharacterDataParser;
import funkin.play.components.HealthIcon;
import funkin.save.Save;
import funkin.ui.freeplay.charselect.PlayableCharacter;
import funkin.ui.MusicBeatSubState;
import funkin.util.assets.DataAssets;
import funkin.util.WindowUtil;
import haxe.Json;
import haxe.ds.StringMap;
import Std;

/**
 * This is a substate that acts as a Character Selection screen.
 */
class CharacterSelectSubState extends MusicBeatSubState {
	var charName:FlxText;
	var charDesc:FlxText;
	var selected:FlxText;
	var numberThing:FlxText;

	var leftDifficultyArrow:FunkinSprite;
	var rightDifficultyArrow:FunkinSprite;
	var keyBox:FunkinSprite;

	var hotkeyCam:FunkinCamera;

	// Arrays for each character.
	var charArrayBF:Array<String> = ['default'];
	var charArrayDad:Array<String> = ['default'];
	var charArrayGF:Array<String> = ['default'];

	// Arrays that are used in combination with pageIndex.
	var charArrays:Array<String> = [charArrayBF, charArrayDad, charArrayGF];
	var characterIDsArray:Array<String> = [characterIDs.bf, characterIDs.gf, characterIDs.dad];

	var lockedCharMap:StringMap<Dynamic> = new StringMap();

	// For the top text in the menu.
	var topText = ["PLAYABLE CHARACTERS", "OPPONENT CHARACTERS", "GIRLFRIEND CHARACTERS"];
	var topTextColor = [0xFF2DB2D2, 0xFFAF66CE, 0xFFA7004C];

	var pages:Array<String> = ['bf', 'dad', 'gf'];
	var charIcon:HealthIcon;
	var iconGrid:Array<HealthIcon> = [];

	var charIndex:Int = 0;
	var pageIndex:Int = 0;
	var songBPM:Float = ModuleHandler.getModule("CharacterHandler").scriptGet('freeplayBPM');

	var curCharID:String = 'default';
	var characterSprite:BaseCharacter;
	var characterIDs:Dynamic = Save.instance.modOptions.get("FunkerSelector");
	var simplifyUI:Bool = Save.instance.modOptions.get("FunkerSelectorSettings").potatoMode;

	public function new() {
		super();
	}

	public override function create():Void {
		super.create();

		setupUIStuff();
		initChars();
		jumpToCurSelected();
	}

	public override function update(elapsed:Float):Void {
		super.update(elapsed);

		conductorInUse.update();

		numberThing.text = "< " + (charIndex + 1) + " / " + charArrays[pageIndex].length + " >";
		numberThing.screenCenter(0x01);

		handleKeyShit();
	}

	function beatHit():Void {
		bopDaThing();
		if (characterSprite != null)
			characterSprite.dance();
	}

	/**
	 * Initializing character data for use in the substate itself.
	 * 
	 * Characters use a JSON file and are loaded from `data/funkerSelector/` and
	 * then parsed, they can specify Game Over music, Blue Ball, 
	 * and Pause Menu music suffixes.
	 * If no character type is specified in the JSON, it is pushed
	 * to the Boyfriend character list. 
	 * If no character ID exists in the file (or the character ID is invalid), the character will be skipped. 
	 */
	function initChars():Void {
		var funkerJSONs = DataAssets.listDataFilesInPath('funkerSelector/');
		var data = null;
		var tempArray = [];

		for (funker in funkerJSONs) {
			trace('[Funker Selector] Loading JSON data for ' + funker);

			try {
				data = Json.parse(Assets.getText(Paths.json('funkerSelector/' + funker)));
			} catch (e:Dynamic) {
				trace(':('); // If only catch blocks actually worked in HScript...
			}

			// If the parsing succeeds, then they get pushed to a temporary array.
			tempArray.push(funker);

			// If the "characterID" field was not found.
			if (data.characterID == null) {
				PolymodErrorHandler.showAlert('Funker Selector JSON Parsing Error',
					'In "' + Assets.getPath(Paths.json('funkerSelector/' + funker)) +
					'":\n\nThe "characterID" field was not found. This character will be skipped to prevent any issues.');
				continue;
			}

			// If the Character ID is "default"
			if (data.characterID == 'default') {
				PolymodErrorHandler.showAlert('Funker Selector JSON Parsing Error',
					'In "'
					+ Assets.getPath(Paths.json('funkerSelector/' + funker))
					+ '":\n\nThe specified Character ID ('
					+ data.characterID
					+
					') is set to "default"! Please change it, since it will conflict with the "default" character object in the menu.\nThis character will be skipped to prevent any issues.');
				continue;
			}

			// If the specified Character ID does not exist in data/characters/
			if (!charJSONCheck(data.characterID)) {
				PolymodErrorHandler.showAlert('Funker Selector JSON Parsing Error',
					'In "'
					+ Assets.getPath(Paths.json('funkerSelector/' + funker))
					+ '":\n\nThe specified Character ID ('
					+ data.characterID
					+ ') is invalid. This character will be skipped to prevent any issues.');
				continue;
			}

			// If the specified Character ID does not match the filename of the JSON
			// TODO: Add a solution to this, so the filename and Character ID can be different
			if (data.characterID != funker) {
				PolymodErrorHandler.showAlert('Funker Selector JSON Parsing Error',
					'In "'
					+ Assets.getPath(Paths.json('funkerSelector/' + funker))
					+ '":\n\nThe specified "characterID" ('
					+ data.characterID
					+ ') does not match the file name of the JSON. ('
					+ funker
					+ '.json'
					+ ')\n\nThis character will be skipped.');
				continue;
			}

			if ((data.mustUnlock != null && data.mustUnlock) && !shouldShowCharacter(data.characterID)) {
				trace('[Funker Selector] Character ID ' + data.characterID + ' is locked!');
				lockedCharMap.set(data.characterID, data);
			}

			if (data.characterType != null) {
				switch (data.characterType) {
					case 'bf', 'player':
						trace('[Funker Selector] Pushing ID ' + data.characterID + ' to "PLAYABLE CHARACTERS"');
						if (charArrayBF.indexOf(data.characterID) == -1)
							charArrayBF.push(data.characterID);
					case 'gf':
						trace('[Funker Selector] Pushing ID ' + data.characterID + ' to "GIRLFRIEND CHARACTERS"');
						if (charArrayGF.indexOf(data.characterID) == -1)
							charArrayGF.push(data.characterID);
					case 'dad', 'opponent':
						trace('[Funker Selector] Pushing ID ' + data.characterID + ' to "OPPONENT CHARACTERS"');
						if (charArrayDad.indexOf(data.characterID) == -1)
							charArrayDad.push(data.characterID);
					default:
						PolymodErrorHandler.showAlert('Funker Selector JSON Parsing Error',
							'In "'
							+ Assets.getPath(Paths.json('funkerSelector/' + funker))
							+ '":\n\nThe specified Character Type ('
							+ data.characterType
							+ ') is invalid. To prevent any issues, you will find this character under "PLAYABLE CHARACTERS".');
						if (charArrayBF.indexOf(data.characterID) == -1)
							charArrayBF.push(data.characterID);
				}
			} else {
				trace('[Funker Selector] Pushing ID ' + data.characterID + ' to "PLAYABLE CHARACTERS"');
				if (charArrayBF.indexOf(data.characterID) == -1)
					charArrayBF.push(data.characterID);
			}
		}

		// VERY BASIC ERROR HANDLING!!
		for (funker in funkerJSONs) {
			if (tempArray.indexOf(funker) == -1) {
				PolymodErrorHandler.showAlert('Funker Selector JSON Parsing Error',
					'In "' + Assets.getPath(Paths.json('funkerSelector/' + funker)) +
					'":\n\nThis character was not loaded due to an issue with their JSON file. Please make sure the syntax is correct.');
				continue;
			}
		}
	}

	/**
	 * Make a super awesome cool icon grid!
	 * @param spacing The spacing of the icons, I guess.
	 * 
	 * This is disabled if "Simplify UI" is turned on in the Options Menu.
	 */
	function createIconGrid(spacing:Int, ?alpha:Float = null):Void {
		var charIconData = curCharID != 'default' ? CharacterDataParser.parseCharacterData(curCharID) : null;
		var x = (FlxG.width - Math.ceil(FlxG.width / spacing) * spacing) / 2;
		var y = (FlxG.height - Math.ceil(FlxG.height / spacing) * spacing) / 2;
		for (i in 0...Math.ceil(FlxG.height / spacing)) {
			for (j in 0...Math.ceil(FlxG.width / spacing)) {
				var icon = new HealthIcon('dad', 0);
				icon.x = x + j * spacing;
				icon.y = y + i * spacing;
				icon.alpha = (alpha != null ? alpha : 0.2);

				if (charIconData != null) {
					icon.configure(charIconData.healthIcon);
				} else {
					icon.configure('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');
				}

				add(icon);
				iconGrid.push(icon);
			}
		}
	}

	/**
	 * Check if the JSON file in `data/characters/` ACTUALLY exists.
	 * 
	 * I wrote this function because OpenFL Assets is case-insensitive
	 * on Windows and macOS. This is for an edge case where the JSON filename
	 * in data/characters/ has different capitalization than the Character ID
	 * specified in the Funker Selector JSON. Because OpenFL is case insensitive, it will
	 * always return true, which confuses Funker Selector!
	 * 
	 * This was reported in issue [#1](https://github.com/AbnormalPoof/FunkerSelector/issues/1)!
	 * 
	 * This should hopefully solve any and all issues like that one.
	 * 
	 * @param string The character ID we're comparing.
	 * @return Returns a true or false if the file exists.
	 */
	function charJSONCheck(string:String):Bool {
		if (Assets.exists(Paths.json('characters/' + string))) {
			var characterFiles = DataAssets.listDataFilesInPath('characters/');
			return characterFiles.indexOf(string) != -1;
		}
		return false;
	}

	/**
	 * Wether or not the character should be shown.
	 * @param characterID The character ID we're using.
	 * @return Bool
	 */
	function shouldShowCharacter(characterID:String):Bool {
		if (PlayerRegistry.instance.isCharacterOwned(characterID)) {
			var ownerID:String = PlayerRegistry.instance.getCharacterOwnerId(characterID);
			var playableCharacter:PlayableCharacter = PlayerRegistry.instance.fetchEntry(ownerID);
			return playableCharacter != null && playableCharacter.isUnlocked();
		}
		return true;
	}

	/**
	 * Configuring the JSON character, setting up position, scale, flipping, etc.
	 */
	function configureChar(data:Null):Void {
		var position = data.position != null ? data.position : [0, 0];
		var scale = data.scale != null ? (data.isPixel ? data.scale * 6 : data.scale) : (data.isPixel ? 6.0 : 1.0);
		characterSprite.x += position[0];
		characterSprite.y += position[1];
		characterSprite.flipX = data.flipX != null ? data.flipX : false;
		characterSprite.scale.set(scale, scale);
		characterSprite.antialiasing = data.isPixel != null ? !data.isPixel : true;
	}

	/**
	 * Set up UI stuff like the BG and text.
	 */
	function setupUIStuff():Void {
		hotkeyCam = new FunkinCamera('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');
		FlxG.cameras.add(hotkeyCam, false);
		hotkeyCam.bgColor = 0x0;
		hotkeyCam.visible = false;

		bg = new FunkinSprite(0, 0);
		bg.makeSolidColor(FlxG.width, FlxG.height, 0xFF000000);
		bg.alpha = 0;

		selectText = new FlxText(170, 400, 0, 'PLACEHOLDER');
		selectText.setFormat(Paths.font("PhantomMuff.ttf"), 50);
		selectText.screenCenter(0x01);
		selectText.y = 10;

		numberThing = new FlxText(170, 400, 0, 'PLACEHOLDER');
		numberThing.setFormat(Paths.font("PhantomMuff.ttf"), 45, null, 'center');
		numberThing.color = 0xFFE3E1E1;
		numberThing.y = 60;

		selected = new FlxText(720, 220, 0, '(SELECTED)');
		selected.setFormat(Paths.font("PhantomMuff.ttf"), 50, null, 'center');
		selected.color = 0xFF53FF38;
		selected.visible = false;

		hotkeyText = new FlxText(990, 15, 0, 'D - Hotkeys');
		hotkeyText.setFormat(Paths.font("PhantomMuff.ttf"), 45, null, 'center');
		hotkeyText.color = 0xFFE3E1E1;

		leftDifficultyArrow = FunkinSprite.createSparrow(20, 300, 'storymenu/ui/arrows');
		leftDifficultyArrow.animation.addByPrefix('idle', 'leftIdle0');
		leftDifficultyArrow.animation.addByPrefix('press', 'leftConfirm0');
		leftDifficultyArrow.animation.play('idle');
		leftDifficultyArrow.scale.set(1.5, 1.5);

		rightDifficultyArrow = FunkinSprite.createSparrow(1200, leftDifficultyArrow.y, 'storymenu/ui/arrows');
		rightDifficultyArrow.animation.addByPrefix('idle', 'rightIdle0');
		rightDifficultyArrow.animation.addByPrefix('press', 'rightConfirm0');
		rightDifficultyArrow.animation.play('idle');
		rightDifficultyArrow.scale.set(1.5, 1.5);

		keyBox = new FunkinSprite(0, 0);
		keyBox.makeSolidColor(600, 600, 0xFF000000);
		keyBox.camera = hotkeyCam;
		keyBox.alpha = 0.8;
		keyBox.screenCenter();

		hotkeys = new FlxText(350, 80, 0,
			'F - Reset everything to default.\n\nJ - Jump to the currently selected character.\n\nQ - Switch to the previous page.\n\nE - Switch to the next page.\n\nESC - Close this.');
		hotkeys.setFormat(Paths.font("PhantomMuff.ttf"), 40);
		hotkeys.camera = hotkeyCam;
		hotkeys.wordWrap = true;
		hotkeys.fieldWidth = 600;

		charIcon = new HealthIcon('dad', 0);

		charName = new FlxText(170, 400, 0, 'PLACEHOLDER');
		charName.setFormat(Paths.font("PhantomMuff.ttf"), 70);
		charName.y = 110;

		add(bg);
		if (!simplifyUI)
			createIconGrid(150, 0.2);
		add(leftDifficultyArrow);
		add(rightDifficultyArrow);
		add(selectText);
		add(numberThing);
		add(selected);
		add(hotkeyText);
		add(charIcon);
		add(charName);
		add(keyBox);
		add(hotkeys);

		WindowUtil.setWindowTitle('Friday Night Funkin\' - Funker Selector Menu');

		FlxTween.tween(bg, {alpha: 0.5}, 0.5, {ease: FlxEase.quartOut});

		trace('[Funker Selector] UI has been set up.');

		conductorInUse.forceBPM(songBPM);
	}

	/**
	 * Bopping the icons, because why not?
	 */
	function bopDaThing():Void {
		if (charIcon != null) {
			if (charIcon.width > charIcon.height) {
				charIcon.setGraphicSize(Std.int(charIcon.width + (150 * charIcon.size.x * 0.2)), 0);
			} else {
				charIcon.setGraphicSize(0, Std.int(charIcon.height + (150 * charIcon.size.y * 0.2)));
			}

			charIcon.angle += 1;

			charIcon.updateHitbox();
			charIcon.updatePosition();
		}
	}

	/**
	 * Flash the screen with a specific color.
	 */
	function flashScreen(color:FlxColor, duration:Float, ?alpha:Float = 1) {
		var duration:Float = duration;
		var alpha:Float = alpha;

		var white = new FunkinSprite(0, 0);
		white.makeSolidColor(FlxG.width, FlxG.height, color);
		white.alpha = 0;
		this.add(white);

		FlxTween.tween(white, {alpha: alpha}, duration, {
			ease: FlxEase.quadOut,
			onComplete: function(twn:FlxTween) {
				FlxTween.tween(white, {alpha: alpha}, duration, {
					ease: FlxEase.quadOut,
					onComplete: function(twn:FlxTween) {
						this.remove(white);
					}
				});
			}
		});
	}

	/**
	 * Reponsible for handling inputs in the menu.
	 */
	function handleKeyShit():Void {
		if (FlxG.keys.justPressed.ESCAPE) {
			if (hotkeyCam.visible) {
				hotkeyCam.visible = false;
			} else {
				FunkinSound.playOnce(Paths.sound('cancelMenu'));

				// Scripted characters overwrite the suffixes when
				// they're shown. So we want to manually reset them!
				PauseSubState.musicSuffix = '';
				GameOverSubState.musicSuffix = '';
				GameOverSubState.blueBallSuffix = '';

				WindowUtil.setWindowTitle('Friday Night Funkin\'');
				close();
			}
		}

		if (!hotkeyCam.visible) {
			if (FlxG.keys.justPressed.LEFT || FlxG.keys.justPressed.RIGHT) {
				FunkinSound.playOnce(Paths.sound('scrollMenu'), 0.4);
				charIndex = (charIndex + (FlxG.keys.justPressed.RIGHT ? 1 : -1) + charArrays[pageIndex].length) % charArrays[pageIndex].length;
				curCharID = charArrays[pageIndex][charIndex];
				updateCharInfo();
			}

			leftDifficultyArrow.animation.play(FlxG.keys.pressed.LEFT ? 'press' : 'idle');
			rightDifficultyArrow.animation.play(FlxG.keys.pressed.RIGHT ? 'press' : 'idle');

			if (FlxG.keys.justPressed.Q || FlxG.keys.justPressed.E) {
				FunkinSound.playOnce(Paths.sound('scrollMenu'), 0.4);
				pageIndex = (pageIndex + (FlxG.keys.justPressed.E ? 1 : -1) + pages.length) % pages.length;
				charIndex = 0;
				curCharID = charArrays[pageIndex][charIndex];
				updateCharInfo();
			}

			if (FlxG.keys.justPressed.J) {
				FunkinSound.playOnce(Paths.sound('scrollMenu'), 0.4);
				jumpToCurSelected();
			}

			if (FlxG.keys.justPressed.F) {
				var shouldPlaySound:Bool = false;
				if (characterIDs.bf != 'default') {
					characterIDs.bf = 'default';
					shouldPlaySound = true;
				}
				if (characterIDs.dad != 'default') {
					characterIDs.dad = 'default';
					shouldPlaySound = true;
				}
				if (characterIDs.gf != 'default') {
					characterIDs.gf = 'default';
					shouldPlaySound = true;
				}
				if (shouldPlaySound) {
					FunkinSound.playOnce(Paths.sound('ranks/great'), 0.4);
					selected.visible = selectedTextVisibility();
					Save.instance.modOptions.set("FunkerSelector", characterIDs);
					Save.instance.flush();
				}
			}

			if (FlxG.keys.justPressed.D) {
				hotkeyCam.visible = true;
			}

			if (FlxG.keys.justPressed.ENTER) {
				var shouldConfirm:Bool = false;
				if (curCharID != characterIDsArray[pageIndex]) {
					if (!lockedCharMap.exists(curCharID)) {
						characterIDsArray[pageIndex] = curCharID;
						shouldConfirm = true;
					}
				}
				if (shouldConfirm) {
					confirmThing();
					selected.visible = selectedTextVisibility();
					Save.instance.modOptions.set("FunkerSelector", characterIDs);
					Save.instance.flush();
				} else {
					FunkinSound.playOnce(Paths.sound('cancelMenu'));
					flashScreen(0xFFFF0000, 0.03, 0.1);
				}
			}
		}
	}

	/**
	 * Jumps to the currently selected character.
	 */
	function jumpToCurSelected():Void {
		charIndex = charArrays[pageIndex].indexOf(characterIDsArray[pageIndex]);
		curCharID = characterIDsArray[pageIndex];
		updateCharInfo();
	}

	function confirmThing():Void {
		FunkinSound.playOnce(Paths.sound('confirmMenu'));
		if (!simplifyUI) {
			characterData = ModuleHandler.getModule("CharacterHandler").scriptCall('parseJSONData', [curCharID]);
			animation = characterData?.characterMenu?.selectedAnim != null ? characterData.characterMenu.selectedAnim : 'hey';
			if (characterSprite != null)
				characterSprite.playAnimation(animation, true, true);
		}
		if (charIcon?.hasAnimation('winning')) {
			// Play the winning animation if it's available.
			charIcon?.playAnimation('winning');

			// I wanted this really cool effect where the icons in the icon grid would also
			// play the winning animation!
			// But let's not play that if "Simplify UI" is turned on.
			if (!simplifyUI && iconGrid != null) {
				for (i in 0...iconGrid.length) {
					var icon = iconGrid[i];
					new FlxTimer().start(0.01 * i, function() {
						icon?.playAnimation('winning');
					});
				}
				new FlxTimer().start(0.3, function() {
					for (i in 0...iconGrid.length) {
						var icon = iconGrid[i];
						new FlxTimer().start(0.01 * i, function() {
							icon?.playAnimation('idle');
						});
					}
				});
			}
		}

		flashScreen(0xFFFFFFFF, 0.03, 0.1);
	}

	function selectedTextVisibility():Bool {
		return curCharID == characterIDsArray[pageIndex];
	}

	function configureText(object:FlxText, ?text:String = "", ?xOffset:Int = 0, ?yOffset:Int = 0):FlxText {

		if (text == null) text = "";
		if (xOffset == null) xOffset = "";
		if (yOffset == null) yOffset = "";

		object.text = text;
		object.x += xOffset;
		object.y += yOffset;
		return object;
	}

	/**
	 * Update character information.
	 */
	function updateCharInfo():Void {
		if (characterSprite != null)
			remove(characterSprite);

		if (charDesc != null)
			remove(charDesc);

		selectText.text = topText[pageIndex];
		selectText.color = topTextColor[pageIndex];
		selectText.screenCenter(0x01);
		selected.visible = selectedTextVisibility();

		charDesc = new FlxText(600, 300, 0, "PLACEHOLDER");
		charDesc.wordWrap = true;
		charDesc.fieldWidth = 550;

		characterData = ModuleHandler.getModule("CharacterHandler").scriptCall('parseJSONData', [curCharID]);
		charIconData = (curCharID != 'default') ? CharacterDataParser.parseCharacterData(curCharID) : null;

		// If "Simplify UI" is enabled in the Options Menu, the sprites will not load.
		if (!simplifyUI) {
			characterSprite = CharacterDataParser.fetchCharacter(curCharID, true);
			if (characterSprite != null) {
				characterSprite.dance();
				if (characterData.characterMenu != null) {
					configureChar(characterData.characterMenu);
				}
				add(characterSprite);
			}
		}
		
		switch (curCharID) {
			case 'default':
				charIcon.configure('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');
				charName.size = 70;
				charName.text = "DEFAULT";
				charDesc.text = "This is the Default character defined by the song.";
				charDesc.x += -20;
				charDesc.fieldWidth += 50;
			default:
				if (lockedCharMap.exists(curCharID)) {
					charName.text = "LOCKED";

					if (characterSprite != null)
						characterSprite.color = 0xFF000000;

					var unlockHint = characterData.description != null
						&& characterData.description.unlockCondition != null ? "\n\nHint: " + characterData.description.unlockCondition : "";

					configureText(charDesc, "This character is locked! I wonder who it could be..." + unlockHint);
				} else {
					charName.text = charIconData?.name;
					charIcon.configure(charIconData?.healthIcon);
					charIcon.size.set(1, 1);
					charIcon.setPosition(550, 160);

					var descText:String = (characterData.description?.text != null) ? characterData.description.text : "No description was specified in the JSON file.";

					configureText(charDesc, descText, characterData.description?.offsets?[0], characterData.description?.offsets?[1]);
				}
		}
		
		// Making it not look so awkward when "Simplify UI" is turned on.
		if (simplifyUI || curCharID == 'default') {
			charIcon?.setPosition(250, 270);
			charIcon?.size.set(2, 2);
		}

		if (curCharID != 'default') {
			charDesc.setFormat(Paths.font("PhantomMuff.ttf"), characterData.description != null && characterData.description.size != null ? characterData.description.size : 38,
				null, 'center');
		} else {
			charDesc.setFormat(Paths.font("PhantomMuff.ttf"), 50, null, 'center');
		}

		if (!simplifyUI) {
			for (icon in iconGrid) {
				if (curCharID != 'default') {
					icon?.configure(charIconData?.healthIcon);
				} else {
					icon?.configure('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');
				}
			}
		}

		if (lockedCharMap.exists(curCharID) && charIcon != null) {
			charIcon.visible = false;
		} else {
			charIcon.visible = true;
		}

		charName.screenCenter(0x01);
		selected.y = charDesc.y - 60;

		add(charDesc);

		trace('[Funker Selector] Updated character information.');
	}
}
